{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DETO_3D User Manual DETO_3D is a multiscale topology optimisation code using the discrete element method. For designing and optimising structures or systems with a focus on descrete behaviours. Getting started The code makes extensive use of LAMMPS objects and syntax therefore the user is directed towards the LAMMPS offical documentation to for a deeper understanding of some of the essential concepts in the operation of DETO_3D however this Manual is intended to provide all the necessary information for operation of the code. User Manual The user manual is layed out as follows 0. introduction 1. Instaling and Building DETO_3D 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D 2. Running DETO_3D 2.1 Input script 2.2 chimap 3. commands 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command 4. Examples 4.1 simply supported beam 4.2 granular mixer Contact If you have any questions about the code or how to use it. Feel free to email it's creator at: c.o'shaughnessy1@ncl.ac.uk","title":"Home"},{"location":"#deto_3d-user-manual","text":"DETO_3D is a multiscale topology optimisation code using the discrete element method. For designing and optimising structures or systems with a focus on descrete behaviours.","title":"DETO_3D User Manual"},{"location":"#getting-started","text":"The code makes extensive use of LAMMPS objects and syntax therefore the user is directed towards the LAMMPS offical documentation to for a deeper understanding of some of the essential concepts in the operation of DETO_3D however this Manual is intended to provide all the necessary information for operation of the code.","title":"Getting started"},{"location":"#user-manual","text":"The user manual is layed out as follows 0. introduction 1. Instaling and Building DETO_3D 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D 2. Running DETO_3D 2.1 Input script 2.2 chimap 3. commands 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command 4. Examples 4.1 simply supported beam 4.2 granular mixer","title":"User Manual"},{"location":"#contact","text":"If you have any questions about the code or how to use it. Feel free to email it's creator at: c.o'shaughnessy1@ncl.ac.uk","title":"Contact"},{"location":"0_introduction/","text":"This is a short introduction to DETO","title":"0. Introduction"},{"location":"1_instaling/1.1_cloning/","text":"Cloning DETO_3D To download the sorce code for DETO_3D you can clone from our repository on GitHub use: $ cd <path> $ git clone git@github.com:Connor-OS/DETO.git $ cd DETO *where is the path to the folder in which you want to install DETO_3D doing this will clone the code from the online repository. You will now have a DETO folder containing both DETO_2D and DETO_3D","title":"1.1. cloning"},{"location":"1_instaling/1.1_cloning/#cloning-deto_3d","text":"To download the sorce code for DETO_3D you can clone from our repository on GitHub use: $ cd <path> $ git clone git@github.com:Connor-OS/DETO.git $ cd DETO *where is the path to the folder in which you want to install DETO_3D doing this will clone the code from the online repository. You will now have a DETO folder containing both DETO_2D and DETO_3D","title":"Cloning DETO_3D"},{"location":"1_instaling/1.2_submodules/","text":"Submodules DETO uses the open source molecular dynamics code LAMMPS as a submodule. To complete the DETO build process you first need to initialise and build the LAMMPS submodule. To do this, from inside the DETO directory to clone the sorce code from the lammps repository $ git submodule init $ git submodule update Make a build directory inside the lammps directory $ cd DETO_3D/lammps $ mkdir build $ cd build Then build the lammps executable $ cmake -D BUILD_SHARED_LIBS=on -D PKG_GRANULAR=on -D PKG_BPM -D PKG_MOLECULE=on -D PKG_MC=on -D LAMMPS_EXCEPTIONS=on -D PKG_PYTHON=on ../cmake $ cmake --build . $ cmake --install . You can now navigate out of the lammps directory and back to DETO_3D cd ../..","title":"1.2. Submodules"},{"location":"1_instaling/1.2_submodules/#submodules","text":"DETO uses the open source molecular dynamics code LAMMPS as a submodule. To complete the DETO build process you first need to initialise and build the LAMMPS submodule. To do this, from inside the DETO directory to clone the sorce code from the lammps repository $ git submodule init $ git submodule update Make a build directory inside the lammps directory $ cd DETO_3D/lammps $ mkdir build $ cd build Then build the lammps executable $ cmake -D BUILD_SHARED_LIBS=on -D PKG_GRANULAR=on -D PKG_BPM -D PKG_MOLECULE=on -D PKG_MC=on -D LAMMPS_EXCEPTIONS=on -D PKG_PYTHON=on ../cmake $ cmake --build . $ cmake --install . You can now navigate out of the lammps directory and back to DETO_3D cd ../..","title":"Submodules"},{"location":"1_instaling/1.3_building/","text":"Building DETO_3D If you have successfully followed cloning and building To build DETO_3D we use CMake to handle compilation. From the DETO_3D directory mkdir build cd build to compile and build DETO_3D use cmake .. cmake --build . This will build a deto executable inside your build folder, this can then be moved anywhere on your system to run","title":"1.3. building"},{"location":"1_instaling/1.3_building/#building-deto_3d","text":"If you have successfully followed cloning and building To build DETO_3D we use CMake to handle compilation. From the DETO_3D directory mkdir build cd build to compile and build DETO_3D use cmake .. cmake --build . This will build a deto executable inside your build folder, this can then be moved anywhere on your system to run","title":"Building DETO_3D"},{"location":"1_instaling/1_index/","text":"Instaling DETO 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D","title":"Instaling DETO"},{"location":"1_instaling/1_index/#instaling-deto","text":"1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D","title":"Instaling DETO"},{"location":"2_running/2.1_input/","text":"Input file Simulations in DETO are run via an input script using the commands described in section 3 in many cases the syntax used to set up the simulation is very similar to LAMMPS itself, as these commands are feed directly into an active LAMMPS instance. The commands designed to specify the optimization are unique to DETO Some other files may be included","title":"2.1. input"},{"location":"2_running/2.1_input/#input-file","text":"Simulations in DETO are run via an input script using the commands described in section 3 in many cases the syntax used to set up the simulation is very similar to LAMMPS itself, as these commands are feed directly into an active LAMMPS instance. The commands designed to specify the optimization are unique to DETO Some other files may be included","title":"Input file"},{"location":"2_running/2.2_chimap/","text":"chimap file Syntax num_mat nmat PROPERTIES: chi type material prop1 prop2 ... one or more material nchi pairs: - nmat = number of materials to be specified in the table bellow followed by: - PROPERTIES: = Keyword telling DETO to start reading the properties for your chimap - must contain chi, material, and type in this order. followed by zero or more other per atom properties that can be set with the LAMMPS set command immediately followed by: - 2 or more lines of space seperated values for the properties specified above. Examples num_mat 12 PROPERTIES: chi material type diameter 0.001 steel 1 1 0.2 steel 2 1 0.4 steel 3 1 0.6 steel 4 1 0.8 steel 5 1 1 steel 6 1 0.001 concrete 7 0.1 0.2 concrete 8 0.2 0.4 concrete 9 0.3 0.6 concrete 10 0.4 0.8 concrete 11 0.5 1 concrete 12 0.6 num_mat 1 PROPERTIES: chi material type 0 homo 1 1 homo 2 Description The chimap file is used to prescribe the mapping of chi values onto particle types, materials, and any other per particle propertiesyou wish to associate with the optimisation. a chimap file is a necessary component of a DETO run and is called from the main input scriot via the opt_map_chi command. the range of chi values given in the chi map will be the range available to the optimization. For calssical topology optimisation you will chose values between 0 and 1 but you may want chi to represent some physical quantity so it can be prescribed above one or even negative. A chi value of zero is permisable, however this is not recomended if a sensitivity type optimisation is choosen due to it's negative effects on material migration. the number of materials defined at the top of the file sets the avialable materials for the optimization. You must then specify that exact number of materials as strings below in the materials column.","title":"2.2. chi map"},{"location":"2_running/2.2_chimap/#chimap-file","text":"","title":"chimap file"},{"location":"2_running/2.2_chimap/#syntax","text":"num_mat nmat PROPERTIES: chi type material prop1 prop2 ... one or more material nchi pairs: - nmat = number of materials to be specified in the table bellow followed by: - PROPERTIES: = Keyword telling DETO to start reading the properties for your chimap - must contain chi, material, and type in this order. followed by zero or more other per atom properties that can be set with the LAMMPS set command immediately followed by: - 2 or more lines of space seperated values for the properties specified above.","title":"Syntax"},{"location":"2_running/2.2_chimap/#examples","text":"num_mat 12 PROPERTIES: chi material type diameter 0.001 steel 1 1 0.2 steel 2 1 0.4 steel 3 1 0.6 steel 4 1 0.8 steel 5 1 1 steel 6 1 0.001 concrete 7 0.1 0.2 concrete 8 0.2 0.4 concrete 9 0.3 0.6 concrete 10 0.4 0.8 concrete 11 0.5 1 concrete 12 0.6 num_mat 1 PROPERTIES: chi material type 0 homo 1 1 homo 2","title":"Examples"},{"location":"2_running/2.2_chimap/#description","text":"The chimap file is used to prescribe the mapping of chi values onto particle types, materials, and any other per particle propertiesyou wish to associate with the optimisation. a chimap file is a necessary component of a DETO run and is called from the main input scriot via the opt_map_chi command. the range of chi values given in the chi map will be the range available to the optimization. For calssical topology optimisation you will chose values between 0 and 1 but you may want chi to represent some physical quantity so it can be prescribed above one or even negative. A chi value of zero is permisable, however this is not recomended if a sensitivity type optimisation is choosen due to it's negative effects on material migration. the number of materials defined at the top of the file sets the avialable materials for the optimization. You must then specify that exact number of materials as strings below in the materials column.","title":"Description"},{"location":"2_running/2.3_potfile/","text":"Potentials file This file specifies all potentials that will be used and allocated throughout the optimization run. it also speciifies the commands that are needed to construct those potentials It gets read into the simulation every time there is","title":"2.3. potfile"},{"location":"2_running/2.3_potfile/#potentials-file","text":"This file specifies all potentials that will be used and allocated throughout the optimization run. it also speciifies the commands that are needed to construct those potentials It gets read into the simulation every time there is","title":"Potentials file"},{"location":"2_running/2_index/","text":"Running DETO 2.1 Input script","title":"Running DETO"},{"location":"2_running/2_index/#running-deto","text":"2.1 Input script","title":"Running DETO"},{"location":"3_commands/3.1_subcomm/","text":"subcomm command Syntax subcomm num_subcomms num_subcomms = integer value for the number of subcommunicators to use Examples subcomm 2 subcomm 6 Description The code is easily parallelizable using the subcomm command. Certain optimisation algorythms available in DETO generate populations of candidate solutions. Each of these needs to be solved independantly before a design itteration can progress creating an opertunity for parallelization. Using the subcomm command your processors will be divided accros n subcommunicators each taking a portion of the candidates population to solve. Results are combined to berform the next design update. As parallelisation is designed to work only in the case of algorythms using populations it will only provide benifit when specifying optimization algorythms such as Genetic algorythm, Particle swarm, or Monte carlo. It will not provide any benifit and could slow the process down if used with the sensitivity or perturbation methods.","title":"3.1. subcomm"},{"location":"3_commands/3.1_subcomm/#subcomm-command","text":"","title":"subcomm command"},{"location":"3_commands/3.1_subcomm/#syntax","text":"subcomm num_subcomms num_subcomms = integer value for the number of subcommunicators to use","title":"Syntax"},{"location":"3_commands/3.1_subcomm/#examples","text":"subcomm 2 subcomm 6","title":"Examples"},{"location":"3_commands/3.1_subcomm/#description","text":"The code is easily parallelizable using the subcomm command. Certain optimisation algorythms available in DETO generate populations of candidate solutions. Each of these needs to be solved independantly before a design itteration can progress creating an opertunity for parallelization. Using the subcomm command your processors will be divided accros n subcommunicators each taking a portion of the candidates population to solve. Results are combined to berform the next design update. As parallelisation is designed to work only in the case of algorythms using populations it will only provide benifit when specifying optimization algorythms such as Genetic algorythm, Particle swarm, or Monte carlo. It will not provide any benifit and could slow the process down if used with the sensitivity or perturbation methods.","title":"Description"},{"location":"3_commands/3.2_lammps/","text":"lammps command Directs a command to be run in lammps Syntax lammps command command can be any syntactically correct command that can be run by LAMMPS. Examples lammps units si lammps create_box 12 box bond/types 68 extra/bond/per/atom 12 lammps create_atoms 1 box lammps fix support support1 setforce 0 0 0 Description The lammps command directs a command to be run in lammps at the start of the optimization to set the initial conditions for the system. It should be used in front of a command that you would use if you were writing an input script in standad lammps. This command sets the conditions that are common between all simulations, you can think of it as being used to set the boundry condions for your optimization. It can be used, for example to set the units and dimensions, create the simulation box and apply fixes. It may be usefull to use run or minimize with this command, but the user should be aware that these operations will not be part of each optimization itteration and will only set the inital configuration. All particles that are intended to be optimized should be defined with this command.","title":"3.2. lammps"},{"location":"3_commands/3.2_lammps/#lammps-command","text":"Directs a command to be run in lammps","title":"lammps command"},{"location":"3_commands/3.2_lammps/#syntax","text":"lammps command command can be any syntactically correct command that can be run by LAMMPS.","title":"Syntax"},{"location":"3_commands/3.2_lammps/#examples","text":"lammps units si lammps create_box 12 box bond/types 68 extra/bond/per/atom 12 lammps create_atoms 1 box lammps fix support support1 setforce 0 0 0","title":"Examples"},{"location":"3_commands/3.2_lammps/#description","text":"The lammps command directs a command to be run in lammps at the start of the optimization to set the initial conditions for the system. It should be used in front of a command that you would use if you were writing an input script in standad lammps. This command sets the conditions that are common between all simulations, you can think of it as being used to set the boundry condions for your optimization. It can be used, for example to set the units and dimensions, create the simulation box and apply fixes. It may be usefull to use run or minimize with this command, but the user should be aware that these operations will not be part of each optimization itteration and will only set the inital configuration. All particles that are intended to be optimized should be defined with this command.","title":"Description"},{"location":"3_commands/3.3_simulation/","text":"TODO","title":"3.3. simulation"},{"location":"3_commands/3.4_add_attribute/","text":"TODO","title":"3.4. add_attribute"},{"location":"3_commands/3.5_opt_map_chi/","text":"TODO","title":"3.5. opt_map_chi"},{"location":"3_commands/3.x.1_opt_type_genetic/","text":"opt_type genetic this command will select a genetic algorithm for optimisation Syntax opt_type genetic pop_size select cross_rate mutation_rate keyword value genetic: style name of this optimisation type pop_size: number of individuals in a single generation of the optimisation select: selection method, can be tournement or roulette cross_rate: probability of crossover between paretn solutions mutation_rate: probability of mutation in a given bit/element zero or more keyword/value pairs may be appended to args keyword: elitism eletism value = fitest fitest = number of fitest solutions to maintain across generations Examples opt_type genetic tournement 50 0.95 0.01 opt_type genetic roulette 200 0.95 0.01 elitism Description This optimisation type will use a genetic algorithm, the algorithm uses a technique inspired by natural selection to perform an efficent exploration of the search space. utilising a technique of selection, cross over, and mutation pop_size","title":"opt_type_genetic"},{"location":"3_commands/3.x.1_opt_type_genetic/#opt_type-genetic","text":"this command will select a genetic algorithm for optimisation","title":"opt_type genetic"},{"location":"3_commands/3.x.1_opt_type_genetic/#syntax","text":"opt_type genetic pop_size select cross_rate mutation_rate keyword value genetic: style name of this optimisation type pop_size: number of individuals in a single generation of the optimisation select: selection method, can be tournement or roulette cross_rate: probability of crossover between paretn solutions mutation_rate: probability of mutation in a given bit/element zero or more keyword/value pairs may be appended to args keyword: elitism eletism value = fitest fitest = number of fitest solutions to maintain across generations","title":"Syntax"},{"location":"3_commands/3.x.1_opt_type_genetic/#examples","text":"opt_type genetic tournement 50 0.95 0.01 opt_type genetic roulette 200 0.95 0.01 elitism","title":"Examples"},{"location":"3_commands/3.x.1_opt_type_genetic/#description","text":"This optimisation type will use a genetic algorithm, the algorithm uses a technique inspired by natural selection to perform an efficent exploration of the search space. utilising a technique of selection, cross over, and mutation pop_size","title":"Description"},{"location":"3_commands/3.x_Opt_type/","text":"[[3.x.1_opt_type_genetic]]","title":"3.x Opt type"},{"location":"3_commands/3.x_add_constraint/","text":"","title":"3.7. add_constraint"},{"location":"3_commands/3.x_add_objective/","text":"","title":"3.8. add_objective"},{"location":"3_commands/3.x_dump/","text":"Dump command normal lammps dump command except dump every refers to every x generations mention the fact that you can still use the normal lammps dump command","title":"3.9. dump"},{"location":"3_commands/3.x_dump/#dump-command","text":"normal lammps dump command except dump every refers to every x generations mention the fact that you can still use the normal lammps dump command","title":"Dump command"},{"location":"3_commands/3.x_opt_type/","text":"","title":"3.6. opt_type"},{"location":"3_commands/3.x_read_potentials/","text":"Read_potentials command","title":"3.10. read_potentials"},{"location":"3_commands/3.x_read_potentials/#read_potentials-command","text":"","title":"Read_potentials command"},{"location":"3_commands/3.x_write_plog/","text":"","title":"3.11. write_plog"},{"location":"3_commands/3_index/","text":"Commands reference This section details all the DETO specific input commands that can be used in an input script. In many cases these commands will be used in combination with LAMMPS commands. Therefore the user is directed towards the LAMMPS Manual for a detailed explanation of these. 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command","title":"Commands reference"},{"location":"3_commands/3_index/#commands-reference","text":"This section details all the DETO specific input commands that can be used in an input script. In many cases these commands will be used in combination with LAMMPS commands. Therefore the user is directed towards the LAMMPS Manual for a detailed explanation of these. 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command","title":"Commands reference"},{"location":"4_examples/4.0_examples/","text":"4.1 simply supported beam 4.2 granular mixer","title":"4.0 examples"},{"location":"4_examples/4.1_simply_supported/","text":"TODO","title":"4.1. simply supported beam"},{"location":"4_examples/4.2_granular/","text":"TODO","title":"4.2. granular"},{"location":"4_examples/4_index/","text":"Examples 4.1 simply supported beam 4.2 granular mixer","title":"Examples"},{"location":"4_examples/4_index/#examples","text":"4.1 simply supported beam 4.2 granular mixer","title":"Examples"}]}