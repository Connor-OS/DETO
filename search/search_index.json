{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DETO_3D User Manual Welcome to DETO_3D, a powerful multiscale topology optimization tool employing the discrete element method. This software is designed to facilitate the creation and optimization of structures or systems, emphasizing discrete behaviors. Getting started The code makes extensive use of LAMMPS objects and syntax therefore the user is directed towards the LAMMPS offical documentation to for a deeper understanding of some of the essential concepts in the operation of DETO_3D however this Manual is intended to provide all the necessary information for operation of the code. User Manual The user manual is layed out as follows 0. introduction 1. Instaling and Building DETO_3D 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D 2. Running DETO_3D 2.1 Input script 2.2 chimap 3. commands 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command 4. Examples 4.1 simply supported beam 4.1.1 Adding a LAMMPS script 4.1.2 Configuring DETO Inputs 4.1.3 Constructing a DETO script 4.1.4 Running an optimisation and analysing outputs Contact If you have any questions about the code or how to use it. Feel free to email it's creator at: c.o'shaughnessy1@ncl.ac.uk","title":"Home"},{"location":"#deto_3d-user-manual","text":"Welcome to DETO_3D, a powerful multiscale topology optimization tool employing the discrete element method. This software is designed to facilitate the creation and optimization of structures or systems, emphasizing discrete behaviors.","title":"DETO_3D User Manual"},{"location":"#getting-started","text":"The code makes extensive use of LAMMPS objects and syntax therefore the user is directed towards the LAMMPS offical documentation to for a deeper understanding of some of the essential concepts in the operation of DETO_3D however this Manual is intended to provide all the necessary information for operation of the code.","title":"Getting started"},{"location":"#user-manual","text":"The user manual is layed out as follows 0. introduction 1. Instaling and Building DETO_3D 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D 2. Running DETO_3D 2.1 Input script 2.2 chimap 3. commands 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command 4. Examples 4.1 simply supported beam 4.1.1 Adding a LAMMPS script 4.1.2 Configuring DETO Inputs 4.1.3 Constructing a DETO script 4.1.4 Running an optimisation and analysing outputs","title":"User Manual"},{"location":"#contact","text":"If you have any questions about the code or how to use it. Feel free to email it's creator at: c.o'shaughnessy1@ncl.ac.uk","title":"Contact"},{"location":"0_introduction/","text":"This is a short introduction to DETO","title":"0 introduction"},{"location":"template/","text":"Title One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"Title"},{"location":"template/#title","text":"One line explanation","title":"Title"},{"location":"template/#syntax","text":"command arguments","title":"Syntax"},{"location":"template/#examples","text":"example 1 example 2","title":"Examples"},{"location":"template/#description","text":"full description","title":"Description"},{"location":"1_instaling/1.1_cloning/","text":"Cloning DETO_3D To download the sorce code for DETO_3D you can clone from our repository on GitHub use: $ cd <path> $ git clone git@github.com:Connor-OS/DETO.git $ cd DETO *where is the path to the folder in which you want to install DETO_3D doing this will clone the code from the online repository. You will now have a DETO folder containing both DETO_2D and DETO_3D","title":"1.1. Cloning"},{"location":"1_instaling/1.1_cloning/#cloning-deto_3d","text":"To download the sorce code for DETO_3D you can clone from our repository on GitHub use: $ cd <path> $ git clone git@github.com:Connor-OS/DETO.git $ cd DETO *where is the path to the folder in which you want to install DETO_3D doing this will clone the code from the online repository. You will now have a DETO folder containing both DETO_2D and DETO_3D","title":"Cloning DETO_3D"},{"location":"1_instaling/1.2_submodules/","text":"Submodules DETO uses the open source molecular dynamics code LAMMPS as a submodule. To complete the DETO build process you first need to initialise and build the LAMMPS submodule. To do this, from inside the DETO directory to clone the sorce code from the lammps repository $ git submodule init $ git submodule update Make a build directory inside the lammps directory $ cd DETO_3D/lammps $ mkdir build $ cd build Then build the lammps executable $ cmake -D BUILD_SHARED_LIBS=on -D PKG_GRANULAR=on -D PKG_BPM -D PKG_MOLECULE=on -D PKG_MC=on -D LAMMPS_EXCEPTIONS=on -D PKG_PYTHON=on ../cmake $ cmake --build . $ cmake --install . You can now navigate out of the lammps directory and back to DETO_3D cd ../..","title":"1.2. Submodules"},{"location":"1_instaling/1.2_submodules/#submodules","text":"DETO uses the open source molecular dynamics code LAMMPS as a submodule. To complete the DETO build process you first need to initialise and build the LAMMPS submodule. To do this, from inside the DETO directory to clone the sorce code from the lammps repository $ git submodule init $ git submodule update Make a build directory inside the lammps directory $ cd DETO_3D/lammps $ mkdir build $ cd build Then build the lammps executable $ cmake -D BUILD_SHARED_LIBS=on -D PKG_GRANULAR=on -D PKG_BPM -D PKG_MOLECULE=on -D PKG_MC=on -D LAMMPS_EXCEPTIONS=on -D PKG_PYTHON=on ../cmake $ cmake --build . $ cmake --install . You can now navigate out of the lammps directory and back to DETO_3D cd ../..","title":"Submodules"},{"location":"1_instaling/1.3_building/","text":"Building DETO_3D If you have successfully followed cloning and building To build DETO_3D we use CMake to handle compilation. From the DETO_3D directory mkdir build cd build to compile and build DETO_3D use cmake .. cmake --build . This will build a deto executable inside your build folder, this can then be moved anywhere on your system to run","title":"1.3. Building"},{"location":"1_instaling/1.3_building/#building-deto_3d","text":"If you have successfully followed cloning and building To build DETO_3D we use CMake to handle compilation. From the DETO_3D directory mkdir build cd build to compile and build DETO_3D use cmake .. cmake --build . This will build a deto executable inside your build folder, this can then be moved anywhere on your system to run","title":"Building DETO_3D"},{"location":"1_instaling/1_index/","text":"Instaling DETO 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D","title":"Instaling DETO"},{"location":"1_instaling/1_index/#instaling-deto","text":"1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D","title":"Instaling DETO"},{"location":"2_running/2.1_input/","text":"Input file Simulations in DETO are run via an input script using the commands described in section 3 in many cases the syntax used to set up the simulation is very similar to LAMMPS itself, as these commands are feed directly into an active LAMMPS instance. The commands designed to specify the optimization are unique to DETO Some other files may be included","title":"2.1. Input"},{"location":"2_running/2.1_input/#input-file","text":"Simulations in DETO are run via an input script using the commands described in section 3 in many cases the syntax used to set up the simulation is very similar to LAMMPS itself, as these commands are feed directly into an active LAMMPS instance. The commands designed to specify the optimization are unique to DETO Some other files may be included","title":"Input file"},{"location":"2_running/2.2_chimap/","text":"chimap file Syntax num_mat nmat PROPERTIES: chi type material prop1 prop2 ... one or more material nchi pairs: - nmat = number of materials to be specified in the table bellow followed by: - PROPERTIES: = Keyword telling DETO to start reading the properties for your chimap - must contain chi, material, and type in this order. followed by zero or more other per atom properties that can be set with the LAMMPS set command immediately followed by: - 2 or more lines of space seperated values for the properties specified above. Examples num_mat 12 PROPERTIES: chi material type diameter 0.001 steel 1 1 0.2 steel 2 1 0.4 steel 3 1 0.6 steel 4 1 0.8 steel 5 1 1 steel 6 1 0.001 concrete 7 0.1 0.2 concrete 8 0.2 0.4 concrete 9 0.3 0.6 concrete 10 0.4 0.8 concrete 11 0.5 1 concrete 12 0.6 num_mat 1 PROPERTIES: chi material type 0 homo 1 1 homo 2 Description The chimap file is used to prescribe the mapping of chi values onto particle types, materials, and any other per particle propertiesyou wish to associate with the optimisation. a chimap file is a necessary component of a DETO run and is called from the main input scriot via the opt_map_chi command. the range of chi values given in the chi map will be the range available to the optimization. For calssical topology optimisation you will chose values between 0 and 1 but you may want chi to represent some physical quantity so it can be prescribed above one or even negative. A chi value of zero is permisable, however this is not recomended if a sensitivity type optimisation is choosen due to it's negative effects on material migration. the number of materials defined at the top of the file sets the avialable materials for the optimization. You must then specify that exact number of materials as strings below in the materials column.","title":"2.2. Chi Map"},{"location":"2_running/2.2_chimap/#chimap-file","text":"","title":"chimap file"},{"location":"2_running/2.2_chimap/#syntax","text":"num_mat nmat PROPERTIES: chi type material prop1 prop2 ... one or more material nchi pairs: - nmat = number of materials to be specified in the table bellow followed by: - PROPERTIES: = Keyword telling DETO to start reading the properties for your chimap - must contain chi, material, and type in this order. followed by zero or more other per atom properties that can be set with the LAMMPS set command immediately followed by: - 2 or more lines of space seperated values for the properties specified above.","title":"Syntax"},{"location":"2_running/2.2_chimap/#examples","text":"num_mat 12 PROPERTIES: chi material type diameter 0.001 steel 1 1 0.2 steel 2 1 0.4 steel 3 1 0.6 steel 4 1 0.8 steel 5 1 1 steel 6 1 0.001 concrete 7 0.1 0.2 concrete 8 0.2 0.4 concrete 9 0.3 0.6 concrete 10 0.4 0.8 concrete 11 0.5 1 concrete 12 0.6 num_mat 1 PROPERTIES: chi material type 0 homo 1 1 homo 2","title":"Examples"},{"location":"2_running/2.2_chimap/#description","text":"The chimap file is used to prescribe the mapping of chi values onto particle types, materials, and any other per particle propertiesyou wish to associate with the optimisation. a chimap file is a necessary component of a DETO run and is called from the main input scriot via the opt_map_chi command. the range of chi values given in the chi map will be the range available to the optimization. For calssical topology optimisation you will chose values between 0 and 1 but you may want chi to represent some physical quantity so it can be prescribed above one or even negative. A chi value of zero is permisable, however this is not recomended if a sensitivity type optimisation is choosen due to it's negative effects on material migration. the number of materials defined at the top of the file sets the avialable materials for the optimization. You must then specify that exact number of materials as strings below in the materials column.","title":"Description"},{"location":"2_running/2.3_potfile/","text":"Potentials file This file specifies all potentials that will be used and allocated throughout the optimization run. it also speciifies the commands that are needed to construct those potentials It gets read into the simulation every time there is","title":"2.3. Potfile"},{"location":"2_running/2.3_potfile/#potentials-file","text":"This file specifies all potentials that will be used and allocated throughout the optimization run. it also speciifies the commands that are needed to construct those potentials It gets read into the simulation every time there is","title":"Potentials file"},{"location":"2_running/2_index/","text":"Running DETO 2.1 Input script","title":"Running DETO"},{"location":"2_running/2_index/#running-deto","text":"2.1 Input script","title":"Running DETO"},{"location":"3_commands/3.10_add_constraint/","text":"add_constraint function Impose a constraint on permisable solutions Syntax add_constraint mat_ID constraint_type style args mat_ID = ID of material to apply constraint to constraint_type = avgchi or local_avgchi style = scale or shift avgchi args = volfrac volfrac = fraction of total design space permisable to be filled with material local_avgchi args = volfrac radius volfrac = fraction of local area permisable to be filled with material radius = radius defining the boundries of local area around each element Examples add_constraint steel avgchi scale 0.6 add_constraint concrete avgchi shift 0.2 add_constraint glass local_avgchi shift 0.45 Description full description","title":"3.10. add_constraint"},{"location":"3_commands/3.10_add_constraint/#add_constraint-function","text":"Impose a constraint on permisable solutions","title":"add_constraint function"},{"location":"3_commands/3.10_add_constraint/#syntax","text":"add_constraint mat_ID constraint_type style args mat_ID = ID of material to apply constraint to constraint_type = avgchi or local_avgchi style = scale or shift avgchi args = volfrac volfrac = fraction of total design space permisable to be filled with material local_avgchi args = volfrac radius volfrac = fraction of local area permisable to be filled with material radius = radius defining the boundries of local area around each element","title":"Syntax"},{"location":"3_commands/3.10_add_constraint/#examples","text":"add_constraint steel avgchi scale 0.6 add_constraint concrete avgchi shift 0.2 add_constraint glass local_avgchi shift 0.45","title":"Examples"},{"location":"3_commands/3.10_add_constraint/#description","text":"full description","title":"Description"},{"location":"3_commands/3.11_dump/","text":"dump command One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"3.11. dump"},{"location":"3_commands/3.11_dump/#dump-command","text":"One line explanation","title":"dump command"},{"location":"3_commands/3.11_dump/#syntax","text":"command arguments","title":"Syntax"},{"location":"3_commands/3.11_dump/#examples","text":"example 1 example 2","title":"Examples"},{"location":"3_commands/3.11_dump/#description","text":"full description","title":"Description"},{"location":"3_commands/3.12_write_plog/","text":"write_plog command One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"3.12. write_plog"},{"location":"3_commands/3.12_write_plog/#write_plog-command","text":"One line explanation","title":"write_plog command"},{"location":"3_commands/3.12_write_plog/#syntax","text":"command arguments","title":"Syntax"},{"location":"3_commands/3.12_write_plog/#examples","text":"example 1 example 2","title":"Examples"},{"location":"3_commands/3.12_write_plog/#description","text":"full description","title":"Description"},{"location":"3_commands/3.13_write_lmp_log/","text":"write_lmp_log command One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"3.13. write_lmp_log"},{"location":"3_commands/3.13_write_lmp_log/#write_lmp_log-command","text":"One line explanation","title":"write_lmp_log command"},{"location":"3_commands/3.13_write_lmp_log/#syntax","text":"command arguments","title":"Syntax"},{"location":"3_commands/3.13_write_lmp_log/#examples","text":"example 1 example 2","title":"Examples"},{"location":"3_commands/3.13_write_lmp_log/#description","text":"full description","title":"Description"},{"location":"3_commands/3.1_subcomm/","text":"subcomm command specify the number of subcomunicators to use for the optimization run. Syntax subcomm num_subcomms num_subcomms = integer value for the number of subcommunicators to use Examples subcomm 2 subcomm 6 Description The code is easily parallelizable using the subcomm command. Certain optimisation algorythms available in DETO generate populations of candidate solutions. Each of these needs to be solved independantly before a design itteration can progress creating an opertunity for parallelization. Using the subcomm command your processors will be divided accros n subcommunicators each taking a portion of the candidates population to solve. Results are combined to berform the next design update. As parallelisation is designed to work only in the case of algorythms using populations it will only provide benifit when specifying optimization algorythms such as Genetic algorythm, Particle swarm, or Monte carlo. It will not provide any benifit and could slow the process down if used with the sensitivity or perturbation methods.","title":"3.1. subcomm"},{"location":"3_commands/3.1_subcomm/#subcomm-command","text":"specify the number of subcomunicators to use for the optimization run.","title":"subcomm command"},{"location":"3_commands/3.1_subcomm/#syntax","text":"subcomm num_subcomms num_subcomms = integer value for the number of subcommunicators to use","title":"Syntax"},{"location":"3_commands/3.1_subcomm/#examples","text":"subcomm 2 subcomm 6","title":"Examples"},{"location":"3_commands/3.1_subcomm/#description","text":"The code is easily parallelizable using the subcomm command. Certain optimisation algorythms available in DETO generate populations of candidate solutions. Each of these needs to be solved independantly before a design itteration can progress creating an opertunity for parallelization. Using the subcomm command your processors will be divided accros n subcommunicators each taking a portion of the candidates population to solve. Results are combined to berform the next design update. As parallelisation is designed to work only in the case of algorythms using populations it will only provide benifit when specifying optimization algorythms such as Genetic algorythm, Particle swarm, or Monte carlo. It will not provide any benifit and could slow the process down if used with the sensitivity or perturbation methods.","title":"Description"},{"location":"3_commands/3.2_lammps/","text":"lammps command Directs a command to be run in lammps. For setting the inital conditions for an optimization. Syntax lammps command command = any syntactically correct command that can be run by LAMMPS Examples lammps units si lammps create_box 12 box bond/types 68 extra/bond/per/atom 12 lammps create_atoms 1 box lammps fix support support1 setforce 0 0 0 Description The lammps command directs a command to be run in lammps at the start of the optimization to set the initial conditions for the system. It can be anny correct [LAMMPS] LAMMPS command. This command sets the conditions that are common between all simulations, you can think of it as being used to set the starting conditions for your optimisation. The current state of the simulation environment will be stored after all commands have been run. This state will be reverted back to before each new simulation It can be used, for example to set the units and dimensions, create the simulation box and apply fixes. It may be usefull to use run or minimize with this command, but the user should be aware that these operations will not be part of each optimization itteration and will only set the inital configuration. All particles that are intended to be optimized should be defined with this command.","title":"3.2. lammps"},{"location":"3_commands/3.2_lammps/#lammps-command","text":"Directs a command to be run in lammps. For setting the inital conditions for an optimization.","title":"lammps command"},{"location":"3_commands/3.2_lammps/#syntax","text":"lammps command command = any syntactically correct command that can be run by LAMMPS","title":"Syntax"},{"location":"3_commands/3.2_lammps/#examples","text":"lammps units si lammps create_box 12 box bond/types 68 extra/bond/per/atom 12 lammps create_atoms 1 box lammps fix support support1 setforce 0 0 0","title":"Examples"},{"location":"3_commands/3.2_lammps/#description","text":"The lammps command directs a command to be run in lammps at the start of the optimization to set the initial conditions for the system. It can be anny correct [LAMMPS] LAMMPS command. This command sets the conditions that are common between all simulations, you can think of it as being used to set the starting conditions for your optimisation. The current state of the simulation environment will be stored after all commands have been run. This state will be reverted back to before each new simulation It can be used, for example to set the units and dimensions, create the simulation box and apply fixes. It may be usefull to use run or minimize with this command, but the user should be aware that these operations will not be part of each optimization itteration and will only set the inital configuration. All particles that are intended to be optimized should be defined with this command.","title":"Description"},{"location":"3_commands/3.3_simulation/","text":"simulation command adds a new simulation to the optimization, specifying its properties Syntax siulation ID type args repeat yes/no repeat_file ID = identifier for specific simulation type = run or cstgs run args = no args cstgs args = (not implemeneted) repeat = keyword followed by yes or no repeat_file = (optional) supply file name to read from if repeat is specified Examples simulation sim1 run repeat no simulation sim2 run repeat yes repeat.dat simulation sim3 cstgs var_force binary 1 10 100000 0.01 repeat no Description Initialize a simulation and define its type and properties. In DETO a Simulation is the set of operations you interned to optimize for, objectives are associated with individual simulations and tracked across optimization steps. Once defined each simulation will be repeated for each sample solution in the process of optimization. The operations are stored as a set of attributes, these take the form of an ordered list of LAMMPS commands that can be executed for each sample, starting from the same inital conditions. You must define one or more simulations to run an optimization, these can be of type run in which the attributes are run a single time for each evaluation of a solution or type cstgs (change something to get something) in this case each simulation is repeated at each evaluation incrementing the value of one or more variables in the simulation untill a predefined criteria is met (WARNING: this method is not implemented in the code yet) Once a simulation is defined you can add attributes, and objectives to it with the add_attribute and add_objective commands respectively. Requirements You must define at least one simulation to run an optimization. Each simulation must contain at least one run or minimize command as a means of evaluating some timesteps of the simulation. Each simulation must have at leas one associated objective which must in turn be used in the overall objective function evaluation to be included in the optimization.","title":"3.3. simulation"},{"location":"3_commands/3.3_simulation/#simulation-command","text":"adds a new simulation to the optimization, specifying its properties","title":"simulation command"},{"location":"3_commands/3.3_simulation/#syntax","text":"siulation ID type args repeat yes/no repeat_file ID = identifier for specific simulation type = run or cstgs run args = no args cstgs args = (not implemeneted) repeat = keyword followed by yes or no repeat_file = (optional) supply file name to read from if repeat is specified","title":"Syntax"},{"location":"3_commands/3.3_simulation/#examples","text":"simulation sim1 run repeat no simulation sim2 run repeat yes repeat.dat simulation sim3 cstgs var_force binary 1 10 100000 0.01 repeat no","title":"Examples"},{"location":"3_commands/3.3_simulation/#description","text":"Initialize a simulation and define its type and properties. In DETO a Simulation is the set of operations you interned to optimize for, objectives are associated with individual simulations and tracked across optimization steps. Once defined each simulation will be repeated for each sample solution in the process of optimization. The operations are stored as a set of attributes, these take the form of an ordered list of LAMMPS commands that can be executed for each sample, starting from the same inital conditions. You must define one or more simulations to run an optimization, these can be of type run in which the attributes are run a single time for each evaluation of a solution or type cstgs (change something to get something) in this case each simulation is repeated at each evaluation incrementing the value of one or more variables in the simulation untill a predefined criteria is met (WARNING: this method is not implemented in the code yet) Once a simulation is defined you can add attributes, and objectives to it with the add_attribute and add_objective commands respectively.","title":"Description"},{"location":"3_commands/3.3_simulation/#requirements","text":"You must define at least one simulation to run an optimization. Each simulation must contain at least one run or minimize command as a means of evaluating some timesteps of the simulation. Each simulation must have at leas one associated objective which must in turn be used in the overall objective function evaluation to be included in the optimization.","title":"Requirements"},{"location":"3_commands/3.4_add_attribute/","text":"add_attribute command add an attribute to a previously specified simulation written in LAMMPS syntax Syntax add_attribute sim_ID command sim_ID = ID of the simulation to add the attribute to command = any syntactically correct command that can be run by LAMMPS. Examples add_attribute Sim1 fix force force_group addforce 0 -1 0 add_attribute VertF minimiz 1.0e-10 1.0e-10 1000 2000 add_attribute tourq run 1000 add_attribute sim2 variable compliance equal -(y[138]+y[137]+y[259]) add_attribute Sim1 unfix force Description add an attribute to a previously defined simulation. In DETO attributes are LAMMPS commands associated with a particular simulation . These commands define the operations that take place during the simulation. the add_attribute command takes as an argument the unique identifier of the simulation to add the attribute to followed by any string that is a syntactically correct LAMMPS command. You should think of these commands as defining the process you intend to optimise. The boundary conditions as well as either quasi-static or dynamic performance of the structure. Therefore it is necessary specify at least one run or minimize command as an attribute per simulation. Since each simulation must track at least one objective which must be a scalar value variable or compute it is often necessary to create attributes defining these values at the end of the simulation run. Note you must avoid using \"set type\" commands here these commands as the optimization process uses types in a special way described in chi_map Requirements Since each the attributes of each simulation are intended to be run repeatedly you must add an attribute to unfix all fix commands you have used at the end of any simulation.","title":"3.4. add_attribute"},{"location":"3_commands/3.4_add_attribute/#add_attribute-command","text":"add an attribute to a previously specified simulation written in LAMMPS syntax","title":"add_attribute command"},{"location":"3_commands/3.4_add_attribute/#syntax","text":"add_attribute sim_ID command sim_ID = ID of the simulation to add the attribute to command = any syntactically correct command that can be run by LAMMPS.","title":"Syntax"},{"location":"3_commands/3.4_add_attribute/#examples","text":"add_attribute Sim1 fix force force_group addforce 0 -1 0 add_attribute VertF minimiz 1.0e-10 1.0e-10 1000 2000 add_attribute tourq run 1000 add_attribute sim2 variable compliance equal -(y[138]+y[137]+y[259]) add_attribute Sim1 unfix force","title":"Examples"},{"location":"3_commands/3.4_add_attribute/#description","text":"add an attribute to a previously defined simulation. In DETO attributes are LAMMPS commands associated with a particular simulation . These commands define the operations that take place during the simulation. the add_attribute command takes as an argument the unique identifier of the simulation to add the attribute to followed by any string that is a syntactically correct LAMMPS command. You should think of these commands as defining the process you intend to optimise. The boundary conditions as well as either quasi-static or dynamic performance of the structure. Therefore it is necessary specify at least one run or minimize command as an attribute per simulation. Since each simulation must track at least one objective which must be a scalar value variable or compute it is often necessary to create attributes defining these values at the end of the simulation run. Note you must avoid using \"set type\" commands here these commands as the optimization process uses types in a special way described in chi_map","title":"Description"},{"location":"3_commands/3.4_add_attribute/#requirements","text":"Since each the attributes of each simulation are intended to be run repeatedly you must add an attribute to unfix all fix commands you have used at the end of any simulation.","title":"Requirements"},{"location":"3_commands/3.5_opt_map_chi/","text":"opt_map_chi command loads chi map from file Syntax opt_map_chi filename filename = path to file containing chi map Examples opt_map_chi chimap.dat opt_map_chi ./inputs/chimap_multi_mat.dat Description This command imports a chi map from the file path specified into your optimization. A chi map is required to run any optimisation in DETO as it is a core part of this implementation determining the way 'per atom' properties are allocated by the optimization process. See the chimap page for details of the formating and syntax of the chi map file. Note you must include one and only one opt_map_chi command in your simulation.","title":"3.5. opt_map_chi"},{"location":"3_commands/3.5_opt_map_chi/#opt_map_chi-command","text":"loads chi map from file","title":"opt_map_chi command"},{"location":"3_commands/3.5_opt_map_chi/#syntax","text":"opt_map_chi filename filename = path to file containing chi map","title":"Syntax"},{"location":"3_commands/3.5_opt_map_chi/#examples","text":"opt_map_chi chimap.dat opt_map_chi ./inputs/chimap_multi_mat.dat","title":"Examples"},{"location":"3_commands/3.5_opt_map_chi/#description","text":"This command imports a chi map from the file path specified into your optimization. A chi map is required to run any optimisation in DETO as it is a core part of this implementation determining the way 'per atom' properties are allocated by the optimization process. See the chimap page for details of the formating and syntax of the chi map file. Note you must include one and only one opt_map_chi command in your simulation.","title":"Description"},{"location":"3_commands/3.6_read_potentials/","text":"read_potentials command loads pot file from file Syntax read_potentials filename arguments Examples read_potentials potfile.dat read_potentials ./inputs/potfile.dat Description full description","title":"3.6. read_potentials"},{"location":"3_commands/3.6_read_potentials/#read_potentials-command","text":"loads pot file from file","title":"read_potentials command"},{"location":"3_commands/3.6_read_potentials/#syntax","text":"read_potentials filename arguments","title":"Syntax"},{"location":"3_commands/3.6_read_potentials/#examples","text":"read_potentials potfile.dat read_potentials ./inputs/potfile.dat","title":"Examples"},{"location":"3_commands/3.6_read_potentials/#description","text":"full description","title":"Description"},{"location":"3_commands/3.7.1_opt_type_genetic/","text":"opt_type genetic this command will select a genetic algorithm for optimisation Syntax opt_type genetic pop_size select cross_rate mutation_rate keyword value genetic: style name of this optimisation type pop_size: number of individuals in a single generation of the optimisation select: selection method, can be tournement or roulette cross_rate: probability of crossover between paretn solutions mutation_rate: probability of mutation in a given bit/element zero or more keyword/value pairs may be appended to args keyword: elitism eletism value = fitest fitest = number of fitest solutions to maintain across generations Examples opt_type genetic tournement 50 0.95 0.01 opt_type genetic roulette 200 0.95 0.01 elitism 10 Description This optimisation type will use a genetic algorithm, the algorithm uses a technique inspired by natural selection to perform an efficent exploration of the search space. utilising a technique of selection, cross over, and mutation pop_size","title":"opt_type genetic"},{"location":"3_commands/3.7.1_opt_type_genetic/#opt_type-genetic","text":"this command will select a genetic algorithm for optimisation","title":"opt_type genetic"},{"location":"3_commands/3.7.1_opt_type_genetic/#syntax","text":"opt_type genetic pop_size select cross_rate mutation_rate keyword value genetic: style name of this optimisation type pop_size: number of individuals in a single generation of the optimisation select: selection method, can be tournement or roulette cross_rate: probability of crossover between paretn solutions mutation_rate: probability of mutation in a given bit/element zero or more keyword/value pairs may be appended to args keyword: elitism eletism value = fitest fitest = number of fitest solutions to maintain across generations","title":"Syntax"},{"location":"3_commands/3.7.1_opt_type_genetic/#examples","text":"opt_type genetic tournement 50 0.95 0.01 opt_type genetic roulette 200 0.95 0.01 elitism 10","title":"Examples"},{"location":"3_commands/3.7.1_opt_type_genetic/#description","text":"This optimisation type will use a genetic algorithm, the algorithm uses a technique inspired by natural selection to perform an efficent exploration of the search space. utilising a technique of selection, cross over, and mutation pop_size","title":"Description"},{"location":"3_commands/3.7_opt_type/","text":"opt_type command specify the style of optimisation to run as well as parameters associated with it Syntax opt_type style args style = genetic or monte-carlo or pertibation genetic args = pop_size select crossover_rate mutation_rate keyword value selection_style = tour or roul keyword = eletism eletism value = fitest monte-carlo args = (not implemented yet) pertibation args = (not implemented yet) Examples opt_type genetic 100 tour 0.95 0.01 opt_type monte-carlo opt_type pertibation Description Define the algorithm to be used for your optimisation. Defining how chi will be updated from between steps as well as whether or not a population of chi is needed. The algorithms available can be split into stochastic and non-stochastic, the stochastic approaches take advantage of parallelisation by generate a chi population (with stochastic variation) which can be evaluated in parallel across multiple subcommunicators . non-stochastic algorithms use a single chi vector updated with gradient based optimisation methods Stochastic: - genetic - monte-carlo Non-stochastic: - perturbation Genetic optimisation uses a genetic algorithm for optimisation, the technique takes inspiration from the process of natural selection. It involves generating a population of pop_size unique solutions. Selecting a subset of the best or the so called 'fittest' solutions, this can be done with either tournament or roulette selection. Combining elements from pairs of selected fittest results at a rate of crossover_rate . Finally some random mutation is applied to individual elements of the new solutions at a rate of mutation_rate to make up the next generation of solutions. Monte-Carlo is an algorithm planned to be added to DETO using a simulated annealing Perturbation uses the method as developed in the supplementary material of 1 . In this method each element is perturbated by a small amount away from its current value and the solution is re-evaluated. The method of finite differences is used to approximate the gradient of the sensitivity here and element chi values are updated accordingly [1] O\u2019Shaughnessy, C., Masoero, E. & Gosling, P.D. Topology optimization using the discrete element method. Part 1: Methodology, validation, and geometric nonlinearity. Meccanica","title":"3.7. opt_type"},{"location":"3_commands/3.7_opt_type/#opt_type-command","text":"specify the style of optimisation to run as well as parameters associated with it","title":"opt_type command"},{"location":"3_commands/3.7_opt_type/#syntax","text":"opt_type style args style = genetic or monte-carlo or pertibation genetic args = pop_size select crossover_rate mutation_rate keyword value selection_style = tour or roul keyword = eletism eletism value = fitest monte-carlo args = (not implemented yet) pertibation args = (not implemented yet)","title":"Syntax"},{"location":"3_commands/3.7_opt_type/#examples","text":"opt_type genetic 100 tour 0.95 0.01 opt_type monte-carlo opt_type pertibation","title":"Examples"},{"location":"3_commands/3.7_opt_type/#description","text":"Define the algorithm to be used for your optimisation. Defining how chi will be updated from between steps as well as whether or not a population of chi is needed. The algorithms available can be split into stochastic and non-stochastic, the stochastic approaches take advantage of parallelisation by generate a chi population (with stochastic variation) which can be evaluated in parallel across multiple subcommunicators . non-stochastic algorithms use a single chi vector updated with gradient based optimisation methods Stochastic: - genetic - monte-carlo Non-stochastic: - perturbation Genetic optimisation uses a genetic algorithm for optimisation, the technique takes inspiration from the process of natural selection. It involves generating a population of pop_size unique solutions. Selecting a subset of the best or the so called 'fittest' solutions, this can be done with either tournament or roulette selection. Combining elements from pairs of selected fittest results at a rate of crossover_rate . Finally some random mutation is applied to individual elements of the new solutions at a rate of mutation_rate to make up the next generation of solutions. Monte-Carlo is an algorithm planned to be added to DETO using a simulated annealing Perturbation uses the method as developed in the supplementary material of 1 . In this method each element is perturbated by a small amount away from its current value and the solution is re-evaluated. The method of finite differences is used to approximate the gradient of the sensitivity here and element chi values are updated accordingly [1] O\u2019Shaughnessy, C., Masoero, E. & Gosling, P.D. Topology optimization using the discrete element method. Part 1: Methodology, validation, and geometric nonlinearity. Meccanica","title":"Description"},{"location":"3_commands/3.8_objective_function/","text":"objective_function command Use this command to add define your objective function. You must have one and only one of these commands in your script. Syntax objective_function function function = any function that can be evaluated in LAMMPS Examples objective_function v_c1 + v_c2 + v_c3 objective_function v_c1 + v_volfrac objective_function v_c1 + Description full description","title":"3.8. objective_function"},{"location":"3_commands/3.8_objective_function/#objective_function-command","text":"Use this command to add define your objective function. You must have one and only one of these commands in your script.","title":"objective_function command"},{"location":"3_commands/3.8_objective_function/#syntax","text":"objective_function function function = any function that can be evaluated in LAMMPS","title":"Syntax"},{"location":"3_commands/3.8_objective_function/#examples","text":"objective_function v_c1 + v_c2 + v_c3 objective_function v_c1 + v_volfrac objective_function v_c1 +","title":"Examples"},{"location":"3_commands/3.8_objective_function/#description","text":"full description","title":"Description"},{"location":"3_commands/3.9_add_objective/","text":"add_objective command Track a varaible from one of your simulations to be used in the objective function. Syntax add_objective sim_ID objective_name objective_lammps_name sim_ID = ID of the simulation to add the attribute to objective_name = unique identifier for this objective objective_lammps_name = name of corresponding variable in simulation this objective is tracking Examples add_objective sim1 c1 comp add_objective udl_beam c2 volfrac Description track a property of a simulation in as a performance indicator, in DETO objectives are outputs from simulation runs that are used to evaluate performance of the system. you must define them relating to a scaler lammps quantity you can combine them using the objective function","title":"3.9. add_objective"},{"location":"3_commands/3.9_add_objective/#add_objective-command","text":"Track a varaible from one of your simulations to be used in the objective function.","title":"add_objective command"},{"location":"3_commands/3.9_add_objective/#syntax","text":"add_objective sim_ID objective_name objective_lammps_name sim_ID = ID of the simulation to add the attribute to objective_name = unique identifier for this objective objective_lammps_name = name of corresponding variable in simulation this objective is tracking","title":"Syntax"},{"location":"3_commands/3.9_add_objective/#examples","text":"add_objective sim1 c1 comp add_objective udl_beam c2 volfrac","title":"Examples"},{"location":"3_commands/3.9_add_objective/#description","text":"track a property of a simulation in as a performance indicator, in DETO objectives are outputs from simulation runs that are used to evaluate performance of the system. you must define them relating to a scaler lammps quantity you can combine them using the objective function","title":"Description"},{"location":"3_commands/3_index/","text":"Commands This section serves as a reference for all the commands that can be used in a DETO_3D input script . These commands allow the user to set up and control the parameters of optimizations, for instance defining the objectives and boundry conditions of the problem, as well as setting up and running the simulation to be optimized. In many cases these commands incorperate LAMMPS syntax, the user is directed towards the LAMMPS Manual for in depth explanation of these. The commands here will provide all the necessary infomation for a user familure with LAMMPS simulations to begin to run optimizations in DETO. 3.1 subcomm 3.2 lammps 3.3 simulation 3.4 add_attribute 3.5 opt_map_chi 3.6 read_potentials 3.7 opt_type 3.8 objective_function 3.9 add_objective 3.10 add_constraint 3.11 dump 3.12 write_plog 3.13 write_lmp_log","title":"Commands"},{"location":"3_commands/3_index/#commands","text":"This section serves as a reference for all the commands that can be used in a DETO_3D input script . These commands allow the user to set up and control the parameters of optimizations, for instance defining the objectives and boundry conditions of the problem, as well as setting up and running the simulation to be optimized. In many cases these commands incorperate LAMMPS syntax, the user is directed towards the LAMMPS Manual for in depth explanation of these. The commands here will provide all the necessary infomation for a user familure with LAMMPS simulations to begin to run optimizations in DETO. 3.1 subcomm 3.2 lammps 3.3 simulation 3.4 add_attribute 3.5 opt_map_chi 3.6 read_potentials 3.7 opt_type 3.8 objective_function 3.9 add_objective 3.10 add_constraint 3.11 dump 3.12 write_plog 3.13 write_lmp_log","title":"Commands"},{"location":"4_examples/4.1.1_Adding_a_LAMMPS_script/","text":"DETO_3D is a superset of LAMMPS, where the integration of LAMMPS commands is central to constructing and executing simulations. In essence, DETO_3D's primary operation involves a user-defined LAMMPS model coupled with a list of interaction properties and a set of boundary conditions to apply in a simulation. The main loop of the DETO_3D program iteratively executes the simulation, updating the interaction properties of the model between each iteration towards an optimal solution. The ground conditions for the optimisation should be defined in a LAMMPS script that Defines initialisation parameters. Creates and defines the initial position of all particles in the simulation. Specifies constraints and the types of any particles that are not included in the optimisation. The following script is provided for the L-shaped example. # ===== SET INITIALISATION PARAMS ======== dimension 2 units si boundary s s p atom_style hybrid sphere bond comm_modify vel yes cutoff 3.2 newton off special_bonds lj 0 1 1 coul 0 1 1 timestep 10-4 # ===== SYSTEM DEFINITION ======== variable nelx equal 50 variable nely equal 50 variable radius equal 0.5 region box block 0 $(v_nelx) 0 $(v_nely) -0.01 0.01 region cutout block 20 $(v_nelx) 20 $(v_nely) -0.01 0.01 side out region lshape intersect 2 box cutout create_box 12 box bond/types 78 extra/bond/per/atom 12 region support_reg block INF INF 49 INF INF INF region force_reg block 49 INF 7.2 8.8 INF INF lattice hex $(v_radius*2) create_atoms 6 region lshape fix 1 all nve neighbor 2.2 bin neigh_modify delay 0 group support_group region support_reg group force_group region force_reg fix support support_group setforce 0 0 0 set group support_group type 12 set group force_group type 12 # ===== DEFINE OUTPUT VARIABLES ======== compute stress all stress/atom NULL bond variable shyd atom -(c_stress[1]+c_stress[2]+c_stress[3])/3 variable sdev atom sqrt(0.5*((c_stress[1]-c_stress[2])^2+(c_stress[2]-c_stress[3])^2+(c_stress[3]-c_stress[1])^2)+3*(c_stress[4]^2+c_stress[5]^2+c_stress[6]^2)) compute nbond all nbond/atom compute tbond all reduce sum c_nbond The commands here are all LAMMPS commands and in fact the script can be run in vanilla LAMMPS. For further deatails of the commands them selves see the official LAMMPS documentation. The script begins by initializing parameters that must be defined before particles are added. Following this, the script defines all particles that will be involved in the optimisation. This is done here by filling an L-shaped region with a regular lattice of particles but these particle positions could be just as easily read from a file. All particles are initialised as type 6 at the start of the optimisation, but these types will be subject to change as the optimisation progresses Next boundary conditions are partially set. A static constraints is applied to the top of the L-shape and the region where force will be applied is also set. Particles in these regions are set to type 12 which they will retain throughout the optimisation as long as this is specified when we describe the DETO inputs in the next section. It's noteworthy that the script refrains from specifying forces or interaction potentials between particles at this point, rendering the system static. The introduction of dynamics is included outside of this script. Only the ground conditions of the optimisation should be included here. Note It is possible to add dynamics into this section of an optimisation. This could be usefull for example if you want to optimise a system mid process. The commands in this script can be thought of as being used to set the system into the condition it has at the start of the optimisation. Any dynamic behaviour defined here will be run only once and not repeated during each itteration. The last section of the script, while not imperative for executing an optimisation, defines a set of output variables. These can be included in dump files, serving for subsequent analysis. The next section details adding the properties of the simulation that may vary throughout the optimisation. These being the types of particles, and interaction potentials between them.","title":"4.1.1 Adding a LAMMPS script"},{"location":"4_examples/4.1.2_Configuring_DETO_Inputs/","text":"The parameter chi can vary throughout an optimisation in DETO of each particle. Chi represents the proportional intensity of the interactions with a particle and can take a value between zero and one. Zero being non-existent particle that has no interactions with neighbours, an one being a particle with penalised interactions with neighbours, see [1] for a more detailed explanation of this parameter. in DETO chi is specified to be selected from a list of discrete possibilities for each particle, this importantly links each value of chi with a specific LAMMPS particle type, that will be linked to the intensity of interaction potentials. This is done in a so called chi map . A chi map must be included in a DETO optimisation and must include at least three columns chi, material, and type. For this example the basic chi map bellow is used featuring 1 material and 11 chi values. chi_map.dat #chimap generated with input_gen.py num_mat 1 PROPERTIES: chi material type 0.001 homo 1 0.1 homo 2 0.2 homo 3 0.3 homo 4 0.4 homo 5 0.5 homo 6 0.6 homo 7 0.7 homo 8 0.8 homo 9 0.9 homo 10 1.0 homo 11 Complementary to the Chi map defined above is the potential file which links the defined particle types and therefore chi values to the intensity of particle to particle interactions. This is done by defining individual unique interactions between each potential combination of chi values this meaning the number of potentials can quickly become very large, and If additional atom types are included that are static and not associate to a chi this number increases again. As can be seen this can become a very long file even with a relatively low number of chi values. In this example since only 11 chi values where used with one static type the number of unique interactions was 78. The structure of this file will vary heavily depending on the types of interaction included in the simulation, but here the file follows the pattern of: defining a group associated with each type defining a bond coefficient for each interaction creating bonds of the correct type between each type and using the defined coefficients deleting the groups so that they can be re-created once the particle types change in the next iteration. potfile.dat #potfile generated with input_gen.py pair_style zero 1.0 pair_coeff * * group 1 type 1 #chi equal 0.0 group 2 type 2 #chi equal 0.1 group 3 type 3 #chi equal 0.2 group 4 type 4 #chi equal 0.3 group 5 type 5 #chi equal 0.4 group 6 type 6 #chi equal 0.5 group 7 type 7 #chi equal 0.6 group 8 type 8 #chi equal 0.7 group 9 type 9 #chi equal 0.8 group 10 type 10 #chi equal 0.9 group 11 type 11 #chi equal 1.0 group 12 type 12 #non-opt bond_style harmonic bond_coeff 1 0.001 1 bond_coeff 2 0.001 1 bond_coeff 3 0.001 1 bond_coeff 4 0.001 1 bond_coeff 5 0.001 1 bond_coeff 6 0.001 1 bond_coeff 7 0.001 1 bond_coeff 8 0.001 1 bond_coeff 9 0.001 1 bond_coeff 10 0.001 1 bond_coeff 11 0.001 1 bond_coeff 12 0.01 1 bond_coeff 13 0.04 1 bond_coeff 14 0.09 1 bond_coeff 15 0.16 1 bond_coeff 16 0.25 1 bond_coeff 17 0.36 1 bond_coeff 18 0.49 1 bond_coeff 19 0.64 1 bond_coeff 20 0.81 1 bond_coeff 21 1 1 bond_coeff 22 0.16 1 bond_coeff 23 0.36 1 bond_coeff 24 0.64 1 bond_coeff 25 1 1 bond_coeff 26 1.44 1 bond_coeff 27 1.96 1 bond_coeff 28 2.56 1 bond_coeff 29 3.24 1 bond_coeff 30 4 1 bond_coeff 31 0.81 1 bond_coeff 32 1.44 1 bond_coeff 33 2.25 1 bond_coeff 34 3.24 1 bond_coeff 35 4.41 1 bond_coeff 36 5.76 1 bond_coeff 37 7.29 1 bond_coeff 38 9 1 bond_coeff 39 2.56 1 bond_coeff 40 4 1 bond_coeff 41 5.76 1 bond_coeff 42 7.84 1 bond_coeff 43 10.24 1 bond_coeff 44 12.96 1 bond_coeff 45 16 1 bond_coeff 46 6.25 1 bond_coeff 47 9 1 bond_coeff 48 12.25 1 bond_coeff 49 16 1 bond_coeff 50 20.25 1 bond_coeff 51 25 1 bond_coeff 52 12.96 1 bond_coeff 53 17.64 1 bond_coeff 54 23.04 1 bond_coeff 55 29.16 1 bond_coeff 56 36 1 bond_coeff 57 24.01 1 bond_coeff 58 31.36 1 bond_coeff 59 39.69 1 bond_coeff 60 49 1 bond_coeff 61 40.96 1 bond_coeff 62 51.84 1 bond_coeff 63 64 1 bond_coeff 64 65.61 1 bond_coeff 65 81 1 bond_coeff 66 100 1 bond_coeff 67 0.001 1 bond_coeff 68 1 1 bond_coeff 69 4 1 bond_coeff 70 9 1 bond_coeff 71 16 1 bond_coeff 72 25 1 bond_coeff 73 36 1 bond_coeff 74 49 1 bond_coeff 75 64 1 bond_coeff 76 81 1 bond_coeff 77 100 1 bond_coeff 78 100 1 create_bonds many 1 1 1 0.9 1.1 create_bonds many 1 2 2 0.9 1.1 create_bonds many 1 3 3 0.9 1.1 create_bonds many 1 4 4 0.9 1.1 create_bonds many 1 5 5 0.9 1.1 create_bonds many 1 6 6 0.9 1.1 create_bonds many 1 7 7 0.9 1.1 create_bonds many 1 8 8 0.9 1.1 create_bonds many 1 9 9 0.9 1.1 create_bonds many 1 10 10 0.9 1.1 create_bonds many 1 11 11 0.9 1.1 create_bonds many 2 2 12 0.9 1.1 create_bonds many 2 3 13 0.9 1.1 create_bonds many 2 4 14 0.9 1.1 create_bonds many 2 5 15 0.9 1.1 create_bonds many 2 6 16 0.9 1.1 create_bonds many 2 7 17 0.9 1.1 create_bonds many 2 8 18 0.9 1.1 create_bonds many 2 9 19 0.9 1.1 create_bonds many 2 10 20 0.9 1.1 create_bonds many 2 11 21 0.9 1.1 create_bonds many 3 3 22 0.9 1.1 create_bonds many 3 4 23 0.9 1.1 create_bonds many 3 5 24 0.9 1.1 create_bonds many 3 6 25 0.9 1.1 create_bonds many 3 7 26 0.9 1.1 create_bonds many 3 8 27 0.9 1.1 create_bonds many 3 9 28 0.9 1.1 create_bonds many 3 10 29 0.9 1.1 create_bonds many 3 11 30 0.9 1.1 create_bonds many 4 4 31 0.9 1.1 create_bonds many 4 5 32 0.9 1.1 create_bonds many 4 6 33 0.9 1.1 create_bonds many 4 7 34 0.9 1.1 create_bonds many 4 8 35 0.9 1.1 create_bonds many 4 9 36 0.9 1.1 create_bonds many 4 10 37 0.9 1.1 create_bonds many 4 11 38 0.9 1.1 create_bonds many 5 5 39 0.9 1.1 create_bonds many 5 6 40 0.9 1.1 create_bonds many 5 7 41 0.9 1.1 create_bonds many 5 8 42 0.9 1.1 create_bonds many 5 9 43 0.9 1.1 create_bonds many 5 10 44 0.9 1.1 create_bonds many 5 11 45 0.9 1.1 create_bonds many 6 6 46 0.9 1.1 create_bonds many 6 7 47 0.9 1.1 create_bonds many 6 8 48 0.9 1.1 create_bonds many 6 9 49 0.9 1.1 create_bonds many 6 10 50 0.9 1.1 create_bonds many 6 11 51 0.9 1.1 create_bonds many 7 7 52 0.9 1.1 create_bonds many 7 8 53 0.9 1.1 create_bonds many 7 9 54 0.9 1.1 create_bonds many 7 10 55 0.9 1.1 create_bonds many 7 11 56 0.9 1.1 create_bonds many 8 8 57 0.9 1.1 create_bonds many 8 9 58 0.9 1.1 create_bonds many 8 10 59 0.9 1.1 create_bonds many 8 11 60 0.9 1.1 create_bonds many 9 9 61 0.9 1.1 create_bonds many 9 10 62 0.9 1.1 create_bonds many 9 11 63 0.9 1.1 create_bonds many 10 10 64 0.9 1.1 create_bonds many 10 11 65 0.9 1.1 create_bonds many 11 11 66 0.9 1.1 create_bonds many 1 12 67 0.9 1.1 create_bonds many 2 12 68 0.9 1.1 create_bonds many 3 12 69 0.9 1.1 create_bonds many 4 12 70 0.9 1.1 create_bonds many 5 12 71 0.9 1.1 create_bonds many 6 12 72 0.9 1.1 create_bonds many 7 12 73 0.9 1.1 create_bonds many 8 12 74 0.9 1.1 create_bonds many 9 12 75 0.9 1.1 create_bonds many 10 12 76 0.9 1.1 create_bonds many 11 12 77 0.9 1.1 create_bonds many 12 12 78 0.9 1.1 group 1 delete group 2 delete group 3 delete group 4 delete group 5 delete group 6 delete group 7 delete group 8 delete group 9 delete group 10 delete group 11 delete #12 particle types #78 bonds created Note Both the input files on this page were auto generated by a python script called input_gen.py included in the GitHub repo for use. In the next section we will detail constructing the script that is run by DETO to run that brings together the LAMMPS model, chi, and potential inputs into an optimisation. [1] O\u2019Shaughnessy, C., Masoero, E. & Gosling, P.D. Topology optimization using the discrete element method. Part 1: Methodology, validation, and geometric nonlinearity. Meccanica","title":"4.1.2 Configuring DETO inputs"},{"location":"4_examples/4.1.3_Constructing_a_DETO_script/","text":"The DETO input script sets up and runs an optimisation in DETO. combines the LAMMPS model, chi map and potential file from the previous steps together and defines the forces and dynamic or quasi-static conditions to optimise against in the form of a simulation. The commands used in this script are unique to DETO and so will not run natively in LAMMPS. To break down the use of the commands in the script below: First opt_type is used to specify a gradient descent optimisation method with a move limit of 0.1 and a total chi fraction of 0.5 meaning that between each step agiven particels chi value cannot fluctuate more than 0.1 and the optimisation is constrained to keep the average chi across the system below 0.5. A single objective function is specified with objective_function this will be linked to a LAMMPS variable with a later command One sub communicator is specified meaning the program will run only a single execution thread. The lammps commands specified in in.Lshape_lmp are read into the system and executed on a LAMMPS instance, to generate the initial configuration of the system. The commands could instead have been written into this script each prepended by the keyword lammps . However it can be useful to store them in a separate file as is done here. The dump command initialises a optimisation wide dump file which takes the same inputs as the lammps dump command except dumps an output ever N optimisation steps instead of simulated time steps here N is specified as 1 to capture a dump after each optimisation step. opt_map_chi reads in the previously defined chi map read_potentials reads in the previously defined potentials file The simulation command instantiates a simulation called Sim1 to be run as part of this optimisation. The add_attribute command is used to specify LAMMPS commands that will be run on each iteration for Sim1 . These add a downwards force of 0.1 to the force_group defined in in.Lshape_lmp and then initialise an energy minimisation. Finally the bond energy of the system is captured in the variable cost func after the simulation has been run. Finally the add_objective command links the LAMMPS variable cost_func to the DETO specific variable c1 to be included in the objective function. # ===== SET OPTIMIZATION STYLE AND PARAMS ======== opt_type 0.1 0.5 gradient_descent objective_function v_c1 # ===== SET UNIVERSE OF SUB-COMMUNICATORS ======== subcomm 1 # ====== INITIAL SETTINGS FOR ALL LAMMPS INSTANCES ======= lammps file ./inputs/in.Lshape_lmp dump 1 all custom 1 ./dump/dump.Lshape id type x y v_shyd v_sdev c_nbond # ====== LOADING CHI MAP AND POTENTIALS FILE ======= opt_map_chi ./inputs/chimap.dat read_potentials ./inputs/potfile.dat # # ======= SET SIMULATION NUMBER 1 (RUN TYPE, NO REPEAT)======= simulation Sim1 run repeat no add_attribute Sim1 fix force force_group addforce 0 -0.1 0 add_attribute Sim1 fix_modify force energy yes add_attribute Sim1 minimize 1.0e-12 1.0e-12 1000000 20000000 #Define variables for cost function add_attribute Sim1 variable cost_func equal ebond # #================== objective variables ============= add_objective Sim1 c1 cost_func This simple script illustrates a complete DETO optimisation. However it can be straightforwardly expanded to include multiple simulations and more complex composite objective functions. In the next section we will run the script shown above and analyse the outputs of the optimisation process.","title":"4.1.3 Constructing a DETO script"},{"location":"4_examples/4.1.4_Running_an_optimisation_and_analysing_outputs/","text":"The script in.Lshape should be run from the command line using ./deto in.Lshape Whilst running DETO will output some useful information to the terminal at each optimisation step such as the objective function and volume fraction. The output of the optimisation is largely analysed through dump files that can record much more extensive information on the system between each optimisation step. These outputs can be configured in much the same way that standard LAMMPS dumps can be to track per particle values. In the example here the line: dump 1 all custom 1 ./dump/dump.Lshape id type x y v_shyd v_sdev c_nbond is included in the script meaning for all particles at each optimisation step the ID, type, x and y coordinates, hydrostatic and deviatoric stress,and number of intact bonds are recorded. A typical way to view this dumped information is via the open source visualisation software Ovito where particles can be visualised and even colour coded with respect to their properties By displaying the particle type it is possible to get a straightforward visual representation of the distribution of chi at any stage of the optimisation and on the layout of the optimised structure. For example here the conventional \"boot\" optimal structure can be seen at step 150 of the optimisation. Other parameters such as stress distribution can be displayed as well giving insight into the location of stress concentrations in the structure such as in this case at the top inner corner of the L. In addition to per particle dump files DETO will also output a so called thermo file by default called thermo.objective that tracks the progression of the defined objective function over the course of the optimisation. Graphically for this example the objective function is shown bellow","title":"4.1.4 Running an optimisation and analysis"},{"location":"4_examples/4.1_L_Shape/","text":"In this section, we will delve into a practical and illustrative example that demonstrates the integration of a LAMMPS simulation into DETO_3D. The problem in this section is the L Shape Test, a popular benchmark from the literature, as described in Ochoa et al. Problem 4.5. seen below. This problem is a well know Benchmark topology optimisation problem studied in more than 20 different research papers, and known for it's distinct \"boot like\" shape. Image source: Ochoa et al. In this section we aim to provide users with a step-by-step guide on how to undertake an optimisation problem in DETO_3D using the L Shape Test as an example, emphasising key considerations such as setting dimensions, defining the search domain, configuring DETO inputs, establishing simulations with appropriate boundary conditions, specifying optimisation parameters a structures through cost functions, running optimisations and analysing output. The detailed walk through will cover the following key aspects in a systematic order: 4.1.1 Adding a LAMMPS script 4.1.2 Configuring DETO Inputs 4.1.3 Constructing a DETO script 4.1.4 Running an optimisation and analysing outputs By following this comprehensive worked example, users will gain practical insights into the effective utilization of DETO_3D in conjunction with LAMMPS simulations, empowering them to tackle complex topology optimization challenges with confidence and precision.","title":"4.1. L Shaped beam"},{"location":"4_examples/4_index/","text":"Examples 4.1 L Shape","title":"Examples"},{"location":"4_examples/4_index/#examples","text":"4.1 L Shape","title":"Examples"}]}