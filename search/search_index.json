{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DETO_3D User Manual DETO_3D is a multiscale topology optimisation code using the discrete element method. For designing and optimising structures or systems with a focus on descrete behaviours. Getting started The code makes extensive use of LAMMPS objects and syntax therefore the user is directed towards the LAMMPS offical documentation to for a deeper understanding of some of the essential concepts in the operation of DETO_3D however this Manual is intended to provide all the necessary information for operation of the code. User Manual The user manual is layed out as follows 0. introduction 1. Instaling and Building DETO_3D 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D 2. Running DETO_3D 2.1 Input script 2.2 chimap 3. commands 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command 4. Examples 4.1 simply supported beam 4.2 granular mixer Contact If you have any questions about the code or how to use it. Feel free to email it's creator at: c.o'shaughnessy1@ncl.ac.uk","title":"Home"},{"location":"#deto_3d-user-manual","text":"DETO_3D is a multiscale topology optimisation code using the discrete element method. For designing and optimising structures or systems with a focus on descrete behaviours.","title":"DETO_3D User Manual"},{"location":"#getting-started","text":"The code makes extensive use of LAMMPS objects and syntax therefore the user is directed towards the LAMMPS offical documentation to for a deeper understanding of some of the essential concepts in the operation of DETO_3D however this Manual is intended to provide all the necessary information for operation of the code.","title":"Getting started"},{"location":"#user-manual","text":"The user manual is layed out as follows 0. introduction 1. Instaling and Building DETO_3D 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D 2. Running DETO_3D 2.1 Input script 2.2 chimap 3. commands 3.1 subcomm command 3.2 lammps command 3.3 simulation command 3.4 add_attribute command 3.5 opt_map_chi command 4. Examples 4.1 simply supported beam 4.2 granular mixer","title":"User Manual"},{"location":"#contact","text":"If you have any questions about the code or how to use it. Feel free to email it's creator at: c.o'shaughnessy1@ncl.ac.uk","title":"Contact"},{"location":"0_introduction/","text":"This is a short introduction to DETO","title":"0 introduction"},{"location":"template/","text":"Title One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"Title"},{"location":"template/#title","text":"One line explanation","title":"Title"},{"location":"template/#syntax","text":"command arguments","title":"Syntax"},{"location":"template/#examples","text":"example 1 example 2","title":"Examples"},{"location":"template/#description","text":"full description","title":"Description"},{"location":"1_instaling/1.1_cloning/","text":"Cloning DETO_3D To download the sorce code for DETO_3D you can clone from our repository on GitHub use: $ cd <path> $ git clone git@github.com:Connor-OS/DETO.git $ cd DETO *where is the path to the folder in which you want to install DETO_3D doing this will clone the code from the online repository. You will now have a DETO folder containing both DETO_2D and DETO_3D","title":"1.1. cloning"},{"location":"1_instaling/1.1_cloning/#cloning-deto_3d","text":"To download the sorce code for DETO_3D you can clone from our repository on GitHub use: $ cd <path> $ git clone git@github.com:Connor-OS/DETO.git $ cd DETO *where is the path to the folder in which you want to install DETO_3D doing this will clone the code from the online repository. You will now have a DETO folder containing both DETO_2D and DETO_3D","title":"Cloning DETO_3D"},{"location":"1_instaling/1.2_submodules/","text":"Submodules DETO uses the open source molecular dynamics code LAMMPS as a submodule. To complete the DETO build process you first need to initialise and build the LAMMPS submodule. To do this, from inside the DETO directory to clone the sorce code from the lammps repository $ git submodule init $ git submodule update Make a build directory inside the lammps directory $ cd DETO_3D/lammps $ mkdir build $ cd build Then build the lammps executable $ cmake -D BUILD_SHARED_LIBS=on -D PKG_GRANULAR=on -D PKG_BPM -D PKG_MOLECULE=on -D PKG_MC=on -D LAMMPS_EXCEPTIONS=on -D PKG_PYTHON=on ../cmake $ cmake --build . $ cmake --install . You can now navigate out of the lammps directory and back to DETO_3D cd ../..","title":"1.2. Submodules"},{"location":"1_instaling/1.2_submodules/#submodules","text":"DETO uses the open source molecular dynamics code LAMMPS as a submodule. To complete the DETO build process you first need to initialise and build the LAMMPS submodule. To do this, from inside the DETO directory to clone the sorce code from the lammps repository $ git submodule init $ git submodule update Make a build directory inside the lammps directory $ cd DETO_3D/lammps $ mkdir build $ cd build Then build the lammps executable $ cmake -D BUILD_SHARED_LIBS=on -D PKG_GRANULAR=on -D PKG_BPM -D PKG_MOLECULE=on -D PKG_MC=on -D LAMMPS_EXCEPTIONS=on -D PKG_PYTHON=on ../cmake $ cmake --build . $ cmake --install . You can now navigate out of the lammps directory and back to DETO_3D cd ../..","title":"Submodules"},{"location":"1_instaling/1.3_building/","text":"Building DETO_3D If you have successfully followed cloning and building To build DETO_3D we use CMake to handle compilation. From the DETO_3D directory mkdir build cd build to compile and build DETO_3D use cmake .. cmake --build . This will build a deto executable inside your build folder, this can then be moved anywhere on your system to run","title":"1.3. building"},{"location":"1_instaling/1.3_building/#building-deto_3d","text":"If you have successfully followed cloning and building To build DETO_3D we use CMake to handle compilation. From the DETO_3D directory mkdir build cd build to compile and build DETO_3D use cmake .. cmake --build . This will build a deto executable inside your build folder, this can then be moved anywhere on your system to run","title":"Building DETO_3D"},{"location":"1_instaling/1_index/","text":"Instaling DETO 1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D","title":"Instaling DETO"},{"location":"1_instaling/1_index/#instaling-deto","text":"1.1 cloning the project 1.2 building submodules 1.3 building DETO_3D","title":"Instaling DETO"},{"location":"2_running/2.1_input/","text":"Input file Simulations in DETO are run via an input script using the commands described in section 3 in many cases the syntax used to set up the simulation is very similar to LAMMPS itself, as these commands are feed directly into an active LAMMPS instance. The commands designed to specify the optimization are unique to DETO Some other files may be included","title":"2.1. input"},{"location":"2_running/2.1_input/#input-file","text":"Simulations in DETO are run via an input script using the commands described in section 3 in many cases the syntax used to set up the simulation is very similar to LAMMPS itself, as these commands are feed directly into an active LAMMPS instance. The commands designed to specify the optimization are unique to DETO Some other files may be included","title":"Input file"},{"location":"2_running/2.2_chimap/","text":"chimap file Syntax num_mat nmat PROPERTIES: chi type material prop1 prop2 ... one or more material nchi pairs: - nmat = number of materials to be specified in the table bellow followed by: - PROPERTIES: = Keyword telling DETO to start reading the properties for your chimap - must contain chi, material, and type in this order. followed by zero or more other per atom properties that can be set with the LAMMPS set command immediately followed by: - 2 or more lines of space seperated values for the properties specified above. Examples num_mat 12 PROPERTIES: chi material type diameter 0.001 steel 1 1 0.2 steel 2 1 0.4 steel 3 1 0.6 steel 4 1 0.8 steel 5 1 1 steel 6 1 0.001 concrete 7 0.1 0.2 concrete 8 0.2 0.4 concrete 9 0.3 0.6 concrete 10 0.4 0.8 concrete 11 0.5 1 concrete 12 0.6 num_mat 1 PROPERTIES: chi material type 0 homo 1 1 homo 2 Description The chimap file is used to prescribe the mapping of chi values onto particle types, materials, and any other per particle propertiesyou wish to associate with the optimisation. a chimap file is a necessary component of a DETO run and is called from the main input scriot via the opt_map_chi command. the range of chi values given in the chi map will be the range available to the optimization. For calssical topology optimisation you will chose values between 0 and 1 but you may want chi to represent some physical quantity so it can be prescribed above one or even negative. A chi value of zero is permisable, however this is not recomended if a sensitivity type optimisation is choosen due to it's negative effects on material migration. the number of materials defined at the top of the file sets the avialable materials for the optimization. You must then specify that exact number of materials as strings below in the materials column.","title":"2.2. chi map"},{"location":"2_running/2.2_chimap/#chimap-file","text":"","title":"chimap file"},{"location":"2_running/2.2_chimap/#syntax","text":"num_mat nmat PROPERTIES: chi type material prop1 prop2 ... one or more material nchi pairs: - nmat = number of materials to be specified in the table bellow followed by: - PROPERTIES: = Keyword telling DETO to start reading the properties for your chimap - must contain chi, material, and type in this order. followed by zero or more other per atom properties that can be set with the LAMMPS set command immediately followed by: - 2 or more lines of space seperated values for the properties specified above.","title":"Syntax"},{"location":"2_running/2.2_chimap/#examples","text":"num_mat 12 PROPERTIES: chi material type diameter 0.001 steel 1 1 0.2 steel 2 1 0.4 steel 3 1 0.6 steel 4 1 0.8 steel 5 1 1 steel 6 1 0.001 concrete 7 0.1 0.2 concrete 8 0.2 0.4 concrete 9 0.3 0.6 concrete 10 0.4 0.8 concrete 11 0.5 1 concrete 12 0.6 num_mat 1 PROPERTIES: chi material type 0 homo 1 1 homo 2","title":"Examples"},{"location":"2_running/2.2_chimap/#description","text":"The chimap file is used to prescribe the mapping of chi values onto particle types, materials, and any other per particle propertiesyou wish to associate with the optimisation. a chimap file is a necessary component of a DETO run and is called from the main input scriot via the opt_map_chi command. the range of chi values given in the chi map will be the range available to the optimization. For calssical topology optimisation you will chose values between 0 and 1 but you may want chi to represent some physical quantity so it can be prescribed above one or even negative. A chi value of zero is permisable, however this is not recomended if a sensitivity type optimisation is choosen due to it's negative effects on material migration. the number of materials defined at the top of the file sets the avialable materials for the optimization. You must then specify that exact number of materials as strings below in the materials column.","title":"Description"},{"location":"2_running/2.3_potfile/","text":"Potentials file This file specifies all potentials that will be used and allocated throughout the optimization run. it also speciifies the commands that are needed to construct those potentials It gets read into the simulation every time there is","title":"2.3. potfile"},{"location":"2_running/2.3_potfile/#potentials-file","text":"This file specifies all potentials that will be used and allocated throughout the optimization run. it also speciifies the commands that are needed to construct those potentials It gets read into the simulation every time there is","title":"Potentials file"},{"location":"2_running/2_index/","text":"Running DETO 2.1 Input script","title":"Running DETO"},{"location":"2_running/2_index/#running-deto","text":"2.1 Input script","title":"Running DETO"},{"location":"3_commands/3.10_add_constraint/","text":"add_constraint function Impose a constraint on permisable solutions Syntax add_constraint mat_ID constraint_type style args mat_ID = ID of material to apply constraint to constraint_type = avgchi or local_avgchi style = scale or shift avgchi args = volfrac volfrac = fraction of total design space permisable to be filled with material local_avgchi args = volfrac radius volfrac = fraction of local area permisable to be filled with material radius = radius defining the boundries of local area around each element Examples add_constraint steel avgchi scale 0.6 add_constraint concrete avgchi shift 0.2 add_constraint glass local_avgchi shift 0.45 Description full description","title":"3.10. add_constraint"},{"location":"3_commands/3.10_add_constraint/#add_constraint-function","text":"Impose a constraint on permisable solutions","title":"add_constraint function"},{"location":"3_commands/3.10_add_constraint/#syntax","text":"add_constraint mat_ID constraint_type style args mat_ID = ID of material to apply constraint to constraint_type = avgchi or local_avgchi style = scale or shift avgchi args = volfrac volfrac = fraction of total design space permisable to be filled with material local_avgchi args = volfrac radius volfrac = fraction of local area permisable to be filled with material radius = radius defining the boundries of local area around each element","title":"Syntax"},{"location":"3_commands/3.10_add_constraint/#examples","text":"add_constraint steel avgchi scale 0.6 add_constraint concrete avgchi shift 0.2 add_constraint glass local_avgchi shift 0.45","title":"Examples"},{"location":"3_commands/3.10_add_constraint/#description","text":"full description","title":"Description"},{"location":"3_commands/3.11_dump/","text":"dump command One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"3.11. dump"},{"location":"3_commands/3.11_dump/#dump-command","text":"One line explanation","title":"dump command"},{"location":"3_commands/3.11_dump/#syntax","text":"command arguments","title":"Syntax"},{"location":"3_commands/3.11_dump/#examples","text":"example 1 example 2","title":"Examples"},{"location":"3_commands/3.11_dump/#description","text":"full description","title":"Description"},{"location":"3_commands/3.12_write_plog/","text":"write_plog command One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"3.12. write_plog"},{"location":"3_commands/3.12_write_plog/#write_plog-command","text":"One line explanation","title":"write_plog command"},{"location":"3_commands/3.12_write_plog/#syntax","text":"command arguments","title":"Syntax"},{"location":"3_commands/3.12_write_plog/#examples","text":"example 1 example 2","title":"Examples"},{"location":"3_commands/3.12_write_plog/#description","text":"full description","title":"Description"},{"location":"3_commands/3.13_write_lmp_log/","text":"write_lmp_log command One line explanation Syntax command arguments Examples example 1 example 2 Description full description","title":"3.13. write_lmp_log"},{"location":"3_commands/3.13_write_lmp_log/#write_lmp_log-command","text":"One line explanation","title":"write_lmp_log command"},{"location":"3_commands/3.13_write_lmp_log/#syntax","text":"command arguments","title":"Syntax"},{"location":"3_commands/3.13_write_lmp_log/#examples","text":"example 1 example 2","title":"Examples"},{"location":"3_commands/3.13_write_lmp_log/#description","text":"full description","title":"Description"},{"location":"3_commands/3.1_subcomm/","text":"subcomm command specify the number of subcomunicators to use for the optimization run. Syntax subcomm num_subcomms num_subcomms = integer value for the number of subcommunicators to use Examples subcomm 2 subcomm 6 Description The code is easily parallelizable using the subcomm command. Certain optimisation algorythms available in DETO generate populations of candidate solutions. Each of these needs to be solved independantly before a design itteration can progress creating an opertunity for parallelization. Using the subcomm command your processors will be divided accros n subcommunicators each taking a portion of the candidates population to solve. Results are combined to berform the next design update. As parallelisation is designed to work only in the case of algorythms using populations it will only provide benifit when specifying optimization algorythms such as Genetic algorythm, Particle swarm, or Monte carlo. It will not provide any benifit and could slow the process down if used with the sensitivity or perturbation methods.","title":"3.1. subcomm"},{"location":"3_commands/3.1_subcomm/#subcomm-command","text":"specify the number of subcomunicators to use for the optimization run.","title":"subcomm command"},{"location":"3_commands/3.1_subcomm/#syntax","text":"subcomm num_subcomms num_subcomms = integer value for the number of subcommunicators to use","title":"Syntax"},{"location":"3_commands/3.1_subcomm/#examples","text":"subcomm 2 subcomm 6","title":"Examples"},{"location":"3_commands/3.1_subcomm/#description","text":"The code is easily parallelizable using the subcomm command. Certain optimisation algorythms available in DETO generate populations of candidate solutions. Each of these needs to be solved independantly before a design itteration can progress creating an opertunity for parallelization. Using the subcomm command your processors will be divided accros n subcommunicators each taking a portion of the candidates population to solve. Results are combined to berform the next design update. As parallelisation is designed to work only in the case of algorythms using populations it will only provide benifit when specifying optimization algorythms such as Genetic algorythm, Particle swarm, or Monte carlo. It will not provide any benifit and could slow the process down if used with the sensitivity or perturbation methods.","title":"Description"},{"location":"3_commands/3.2_lammps/","text":"lammps command Directs a command to be run in lammps. For setting the inital conditions for an optimization. Syntax lammps command command = any syntactically correct command that can be run by LAMMPS Examples lammps units si lammps create_box 12 box bond/types 68 extra/bond/per/atom 12 lammps create_atoms 1 box lammps fix support support1 setforce 0 0 0 Description The lammps command directs a command to be run in lammps at the start of the optimization to set the initial conditions for the system. It can be anny correct [LAMMPS] LAMMPS command. This command sets the conditions that are common between all simulations, you can think of it as being used to set the starting conditions for your optimization. The current state of the simulation enviroment will be stored after all lammps commands have been run. This state will be reverted back to before each new simulation It can be used, for example to set the units and dimensions, create the simulation box and apply fixes. It may be usefull to use run or minimize with this command, but the user should be aware that these operations will not be part of each optimization itteration and will only set the inital configuration. All particles that are intended to be optimized should be defined with this command.","title":"3.2. lammps"},{"location":"3_commands/3.2_lammps/#lammps-command","text":"Directs a command to be run in lammps. For setting the inital conditions for an optimization.","title":"lammps command"},{"location":"3_commands/3.2_lammps/#syntax","text":"lammps command command = any syntactically correct command that can be run by LAMMPS","title":"Syntax"},{"location":"3_commands/3.2_lammps/#examples","text":"lammps units si lammps create_box 12 box bond/types 68 extra/bond/per/atom 12 lammps create_atoms 1 box lammps fix support support1 setforce 0 0 0","title":"Examples"},{"location":"3_commands/3.2_lammps/#description","text":"The lammps command directs a command to be run in lammps at the start of the optimization to set the initial conditions for the system. It can be anny correct [LAMMPS] LAMMPS command. This command sets the conditions that are common between all simulations, you can think of it as being used to set the starting conditions for your optimization. The current state of the simulation enviroment will be stored after all lammps commands have been run. This state will be reverted back to before each new simulation It can be used, for example to set the units and dimensions, create the simulation box and apply fixes. It may be usefull to use run or minimize with this command, but the user should be aware that these operations will not be part of each optimization itteration and will only set the inital configuration. All particles that are intended to be optimized should be defined with this command.","title":"Description"},{"location":"3_commands/3.3_simulation/","text":"simulation command adds a new simulation to the optimization, specifying its properties Syntax siulation ID type repeat yes/no repeat_file ID = identifier for specific simulation type = run or cstgs repeat = keyword followed by yes or no repeat_file = (optional) supply file name to read from if repeat is specified Examples simulation Sim1 run repeat no simulation Sim2 run repeat yes repeat.dat Description TODO","title":"3.3. simulation"},{"location":"3_commands/3.3_simulation/#simulation-command","text":"adds a new simulation to the optimization, specifying its properties","title":"simulation command"},{"location":"3_commands/3.3_simulation/#syntax","text":"siulation ID type repeat yes/no repeat_file ID = identifier for specific simulation type = run or cstgs repeat = keyword followed by yes or no repeat_file = (optional) supply file name to read from if repeat is specified","title":"Syntax"},{"location":"3_commands/3.3_simulation/#examples","text":"simulation Sim1 run repeat no simulation Sim2 run repeat yes repeat.dat","title":"Examples"},{"location":"3_commands/3.3_simulation/#description","text":"TODO","title":"Description"},{"location":"3_commands/3.4_add_attribute/","text":"add_attribute command add an attribute to a previously specified simulation writen in LAMMPS syntax Syntax add_attribute sim_ID command sim_ID = ID of the simulation to add the attribute to command = any syntactically correct command that can be run by LAMMPS. Examples add_attribute Sim1 fix force force_group addforce 0 -1 0 add_attribute VertF minimize 1.0e-10 1.0e-10 1000 2000 add_attribute tourq run 1000 Description Similar to the [[lammps]] command this command takes as an argument any string that is a correct LAMMPS command. These commands are associated with a specific simulation, they make up the body of that simulation. They should be used to set the boundry conditions of the simulation as well as run the simulation. You should think of these commands as defining the conditions you are intending to optimize for Note you must avoid using \"set type\" commands here these commands as the optimization process uses types in a special way described in chi_map","title":"3.4. add_attribute"},{"location":"3_commands/3.4_add_attribute/#add_attribute-command","text":"add an attribute to a previously specified simulation writen in LAMMPS syntax","title":"add_attribute command"},{"location":"3_commands/3.4_add_attribute/#syntax","text":"add_attribute sim_ID command sim_ID = ID of the simulation to add the attribute to command = any syntactically correct command that can be run by LAMMPS.","title":"Syntax"},{"location":"3_commands/3.4_add_attribute/#examples","text":"add_attribute Sim1 fix force force_group addforce 0 -1 0 add_attribute VertF minimize 1.0e-10 1.0e-10 1000 2000 add_attribute tourq run 1000","title":"Examples"},{"location":"3_commands/3.4_add_attribute/#description","text":"Similar to the [[lammps]] command this command takes as an argument any string that is a correct LAMMPS command. These commands are associated with a specific simulation, they make up the body of that simulation. They should be used to set the boundry conditions of the simulation as well as run the simulation. You should think of these commands as defining the conditions you are intending to optimize for Note you must avoid using \"set type\" commands here these commands as the optimization process uses types in a special way described in chi_map","title":"Description"},{"location":"3_commands/3.5_opt_map_chi/","text":"opt_map_chi command loads chi map from file Syntax opt_map_chi filename filename = path to file containing chi map Examples opt_map_chi chimap.dat opt_map_chi ./inputs/chimap_multi_mat.dat Description This command imports a chi map from the file path specified into your optimization. A chi map is required to run any optimisation in DETO as it is a core part of this implementation determining the way 'per atom' properties are allocated by the optimization process. See the chimap page for details of the formating and syntax of the chi map file. Note you must include one and only one opt_map_chi command in your simulation.","title":"3.5. opt_map_chi"},{"location":"3_commands/3.5_opt_map_chi/#opt_map_chi-command","text":"loads chi map from file","title":"opt_map_chi command"},{"location":"3_commands/3.5_opt_map_chi/#syntax","text":"opt_map_chi filename filename = path to file containing chi map","title":"Syntax"},{"location":"3_commands/3.5_opt_map_chi/#examples","text":"opt_map_chi chimap.dat opt_map_chi ./inputs/chimap_multi_mat.dat","title":"Examples"},{"location":"3_commands/3.5_opt_map_chi/#description","text":"This command imports a chi map from the file path specified into your optimization. A chi map is required to run any optimisation in DETO as it is a core part of this implementation determining the way 'per atom' properties are allocated by the optimization process. See the chimap page for details of the formating and syntax of the chi map file. Note you must include one and only one opt_map_chi command in your simulation.","title":"Description"},{"location":"3_commands/3.6_read_potentials/","text":"read_potentials command loads pot file from file Syntax read_potentials filename arguments Examples read_potentials potfile.dat read_potentials ./inputs/potfile.dat Description full description","title":"3.6. read_potentials"},{"location":"3_commands/3.6_read_potentials/#read_potentials-command","text":"loads pot file from file","title":"read_potentials command"},{"location":"3_commands/3.6_read_potentials/#syntax","text":"read_potentials filename arguments","title":"Syntax"},{"location":"3_commands/3.6_read_potentials/#examples","text":"read_potentials potfile.dat read_potentials ./inputs/potfile.dat","title":"Examples"},{"location":"3_commands/3.6_read_potentials/#description","text":"full description","title":"Description"},{"location":"3_commands/3.7.1_opt_type_genetic/","text":"opt_type genetic this command will select a genetic algorithm for optimisation Syntax opt_type genetic pop_size select cross_rate mutation_rate keyword value genetic: style name of this optimisation type pop_size: number of individuals in a single generation of the optimisation select: selection method, can be tournement or roulette cross_rate: probability of crossover between paretn solutions mutation_rate: probability of mutation in a given bit/element zero or more keyword/value pairs may be appended to args keyword: elitism eletism value = fitest fitest = number of fitest solutions to maintain across generations Examples opt_type genetic tournement 50 0.95 0.01 opt_type genetic roulette 200 0.95 0.01 elitism 10 Description This optimisation type will use a genetic algorithm, the algorithm uses a technique inspired by natural selection to perform an efficent exploration of the search space. utilising a technique of selection, cross over, and mutation pop_size","title":"opt_type_genetic"},{"location":"3_commands/3.7.1_opt_type_genetic/#opt_type-genetic","text":"this command will select a genetic algorithm for optimisation","title":"opt_type genetic"},{"location":"3_commands/3.7.1_opt_type_genetic/#syntax","text":"opt_type genetic pop_size select cross_rate mutation_rate keyword value genetic: style name of this optimisation type pop_size: number of individuals in a single generation of the optimisation select: selection method, can be tournement or roulette cross_rate: probability of crossover between paretn solutions mutation_rate: probability of mutation in a given bit/element zero or more keyword/value pairs may be appended to args keyword: elitism eletism value = fitest fitest = number of fitest solutions to maintain across generations","title":"Syntax"},{"location":"3_commands/3.7.1_opt_type_genetic/#examples","text":"opt_type genetic tournement 50 0.95 0.01 opt_type genetic roulette 200 0.95 0.01 elitism 10","title":"Examples"},{"location":"3_commands/3.7.1_opt_type_genetic/#description","text":"This optimisation type will use a genetic algorithm, the algorithm uses a technique inspired by natural selection to perform an efficent exploration of the search space. utilising a technique of selection, cross over, and mutation pop_size","title":"Description"},{"location":"3_commands/3.7_opt_type/","text":"opt_type command specify the style of optimization to run as well as parameters asociated with it Syntax opt_type style args style = genetic or monte-carlo or pertibation genetic args = pop_size select crossover_rate mutation_rate keyword value selection_style = tour or roul keyword = eletism eletism value = fitest monte-carlo args = (not implemented yet) pertibation args = (not implemented yet) Examples opt_type genetic 100 tour 0.95 0.01 opt_type monte-carlo opt_type pertibation Description Define the algorythm to be used for your optimization. Defining how chi will be updated from between steps as well as whether or not a population of chi is needed. The algorythms available can be split into stocastic and nonstochastic, the stocastic approaches take advantage of parralelisation by generate a chi population (with stocastic variation) which can be evaluated in parrallel across multiple subcommunicators . nonstochastic algorythms use a single chi vector updated with gradient based optimisation methods Stocastic: - genetic - monte-carlo Nonstocastic: - pertibation Genetic optimization uses a genetic algorythm for optimisation, the technique takes inspiration from the process of natural selection. It involves generating a population of pop_size unique solutions. Selecting a subset of the best or the so called 'fittest' solutions, this can be done with either tournement or roulette selection. Combining elements from pairs of selected fitest results at a rate of crossover_rate . Finally some random mutation is applied to individual elements of the new solutions at a rate of mutation_rate to make up the next generation of solutions. Monte-Carlo is an algorythim planned to be added to DETO using a simulated annealing Pertibation uses the method as developed in the supplementary material of [1]. In this method each element is pertibated by a small amount away from its current value and the solution is re-evaluated. The method of finite differences is used to approximate the gradient of the sensitivity here and element chi values are updated accordingly [1] O\u2019Shaughnessy, C., Masoero, E. & Gosling, P.D. Topology optimization using the discrete element method. Part 1: Methodology, validation, and geometric nonlinearity. Meccanica","title":"3.7. opt_type"},{"location":"3_commands/3.7_opt_type/#opt_type-command","text":"specify the style of optimization to run as well as parameters asociated with it","title":"opt_type command"},{"location":"3_commands/3.7_opt_type/#syntax","text":"opt_type style args style = genetic or monte-carlo or pertibation genetic args = pop_size select crossover_rate mutation_rate keyword value selection_style = tour or roul keyword = eletism eletism value = fitest monte-carlo args = (not implemented yet) pertibation args = (not implemented yet)","title":"Syntax"},{"location":"3_commands/3.7_opt_type/#examples","text":"opt_type genetic 100 tour 0.95 0.01 opt_type monte-carlo opt_type pertibation","title":"Examples"},{"location":"3_commands/3.7_opt_type/#description","text":"Define the algorythm to be used for your optimization. Defining how chi will be updated from between steps as well as whether or not a population of chi is needed. The algorythms available can be split into stocastic and nonstochastic, the stocastic approaches take advantage of parralelisation by generate a chi population (with stocastic variation) which can be evaluated in parrallel across multiple subcommunicators . nonstochastic algorythms use a single chi vector updated with gradient based optimisation methods Stocastic: - genetic - monte-carlo Nonstocastic: - pertibation Genetic optimization uses a genetic algorythm for optimisation, the technique takes inspiration from the process of natural selection. It involves generating a population of pop_size unique solutions. Selecting a subset of the best or the so called 'fittest' solutions, this can be done with either tournement or roulette selection. Combining elements from pairs of selected fitest results at a rate of crossover_rate . Finally some random mutation is applied to individual elements of the new solutions at a rate of mutation_rate to make up the next generation of solutions. Monte-Carlo is an algorythim planned to be added to DETO using a simulated annealing Pertibation uses the method as developed in the supplementary material of [1]. In this method each element is pertibated by a small amount away from its current value and the solution is re-evaluated. The method of finite differences is used to approximate the gradient of the sensitivity here and element chi values are updated accordingly [1] O\u2019Shaughnessy, C., Masoero, E. & Gosling, P.D. Topology optimization using the discrete element method. Part 1: Methodology, validation, and geometric nonlinearity. Meccanica","title":"Description"},{"location":"3_commands/3.8_objective_function/","text":"objective_function command Use this command to add define your objective function. You must have one and only one of these commands in your script. Syntax objective_function function function = any function that can be evaluated in LAMMPS Examples objective_function v_c1 + v_c2 + v_c3 objective_function v_c1 + v_volfrac objective_function v_c1 + Description full description","title":"3.8. objective_function"},{"location":"3_commands/3.8_objective_function/#objective_function-command","text":"Use this command to add define your objective function. You must have one and only one of these commands in your script.","title":"objective_function command"},{"location":"3_commands/3.8_objective_function/#syntax","text":"objective_function function function = any function that can be evaluated in LAMMPS","title":"Syntax"},{"location":"3_commands/3.8_objective_function/#examples","text":"objective_function v_c1 + v_c2 + v_c3 objective_function v_c1 + v_volfrac objective_function v_c1 +","title":"Examples"},{"location":"3_commands/3.8_objective_function/#description","text":"full description","title":"Description"},{"location":"3_commands/3.9_add_objective/","text":"add_objective command Track a varaible from one of your simulations to be used in the objective function. Syntax add_objective sim_ID objective_name objective_lammps_name sim_ID = ID of the simulation to add the attribute to objective_name = unique identifier for this objective objective_lammps_name = name of corresponding variable in simulation this objective is tracking Examples add_objective Sim1 c1 comp add_objective udl_beam c2 volfrac Description","title":"3.9. add_objective"},{"location":"3_commands/3.9_add_objective/#add_objective-command","text":"Track a varaible from one of your simulations to be used in the objective function.","title":"add_objective command"},{"location":"3_commands/3.9_add_objective/#syntax","text":"add_objective sim_ID objective_name objective_lammps_name sim_ID = ID of the simulation to add the attribute to objective_name = unique identifier for this objective objective_lammps_name = name of corresponding variable in simulation this objective is tracking","title":"Syntax"},{"location":"3_commands/3.9_add_objective/#examples","text":"add_objective Sim1 c1 comp add_objective udl_beam c2 volfrac","title":"Examples"},{"location":"3_commands/3.9_add_objective/#description","text":"","title":"Description"},{"location":"3_commands/3_index/","text":"Commands This section serves as a reference for all the commands that can be used in a DETO_3D input script . These commands allow the user to set up and control the parameters of optimizations, for instance defining the objectives and boundry conditions of the problem, as well as setting up and running the simulation to be optimized. In many cases these commands incorperate LAMMPS syntax, the user is directed towards the LAMMPS Manual for in depth explanation of these. The commands here will provide all the necessary infomation for a user familure with LAMMPS simulations to begin to run optimizations in DETO. 3.1 subcomm 3.2 lammps 3.3 simulation 3.4 add_attribute 3.5 opt_map_chi 3.6 read_potentials 3.7 opt_type 3.8 objective_function 3.9 add_objective 3.10 add_constraint 3.11 dump 3.12 write_plog 3.13 write_lmp_log","title":"Commands"},{"location":"3_commands/3_index/#commands","text":"This section serves as a reference for all the commands that can be used in a DETO_3D input script . These commands allow the user to set up and control the parameters of optimizations, for instance defining the objectives and boundry conditions of the problem, as well as setting up and running the simulation to be optimized. In many cases these commands incorperate LAMMPS syntax, the user is directed towards the LAMMPS Manual for in depth explanation of these. The commands here will provide all the necessary infomation for a user familure with LAMMPS simulations to begin to run optimizations in DETO. 3.1 subcomm 3.2 lammps 3.3 simulation 3.4 add_attribute 3.5 opt_map_chi 3.6 read_potentials 3.7 opt_type 3.8 objective_function 3.9 add_objective 3.10 add_constraint 3.11 dump 3.12 write_plog 3.13 write_lmp_log","title":"Commands"},{"location":"4_examples/4.0_examples/","text":"4.1 simply supported beam 4.2 granular mixer","title":"4.0 examples"},{"location":"4_examples/4.1_simply_supported/","text":"TODO","title":"4.1. simply supported beam"},{"location":"4_examples/4.2_granular/","text":"TODO","title":"4.2. granular"},{"location":"4_examples/4_index/","text":"Examples 4.1 simply supported beam 4.2 granular mixer","title":"Examples"},{"location":"4_examples/4_index/#examples","text":"4.1 simply supported beam 4.2 granular mixer","title":"Examples"}]}